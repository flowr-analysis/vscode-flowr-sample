"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectAllSlicingCriteria = collectAllSlicingCriteria;
const assert_1 = require("../../util/assert");
const arrays_1 = require("../../util/arrays");
const r_function_call_1 = require("../../r-bridge/lang-4.x/ast/model/nodes/r-function-call");
/**
 * Will create all possible slicing criteria for the given ast, based on the {@link SlicingCriteriaFilter}.
 * The slicing criteria will be *ordered* (i.e., it will not return `[1:2,3:4]` and `[3:4,1:2]` if `maximumSize` \> 1).
 * If there are not enough matching nodes within the ast, this will return *no* slicing criteria!
 */
function* collectAllSlicingCriteria(ast, filter) {
    (0, assert_1.guard)(filter.minimumSize >= 1, `Minimum size must be at least 1, but was ${filter.minimumSize}`);
    (0, assert_1.guard)(filter.maximumSize >= filter.minimumSize, `Maximum size must be at least minimum size, but was ${filter.maximumSize} < ${filter.minimumSize}`);
    const potentialSlicingNodes = filter.collectAll(ast);
    if (potentialSlicingNodes.length < filter.minimumSize) {
        return;
    }
    for (const combination of (0, arrays_1.getUniqueCombinationsOfSize)(potentialSlicingNodes, filter.minimumSize, filter.maximumSize)) {
        const c = combination.filter(n => n !== undefined && n !== r_function_call_1.EmptyArgument);
        if (c.length > 0) {
            yield c.map(n => `$${n}`);
        }
    }
}
//# sourceMappingURL=collect-all.js.map