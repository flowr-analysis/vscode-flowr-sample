"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseLog = void 0;
exports.normalize = normalize;
exports.convertPreparedParsedData = convertPreparedParsedData;
const format_1 = require("./format");
const log_1 = require("../../../../../util/log");
const decorate_1 = require("../../model/processing/decorate");
const normalize_root_1 = require("../xml/internal/structure/normalize-root");
const input_format_1 = require("../xml/input-format");
exports.parseLog = log_1.log.getSubLogger({ name: 'ast-parser' });
function normalize(jsonString, getId = (0, decorate_1.deterministicCountingIdGenerator)(0)) {
    const data = { currentRange: undefined, currentLexeme: undefined };
    const object = convertPreparedParsedData((0, format_1.prepareParsedData)(jsonString));
    return (0, decorate_1.decorateAst)((0, normalize_root_1.normalizeRootObjToAst)(data, object), getId);
}
function convertPreparedParsedData(rootEntries) {
    return {
        ["exprlist" /* RawRType.ExpressionList */]: {
            [input_format_1.nameKey]: "exprlist" /* RawRType.ExpressionList */,
            [input_format_1.childrenKey]: rootEntries.map(convertEntry)
        }
    };
}
function convertEntry(csvEntry) {
    const xmlEntry = {
        [input_format_1.nameKey]: csvEntry.token,
        [input_format_1.attributesKey]: {
            'line1': csvEntry.line1,
            'col1': csvEntry.col1,
            'line2': csvEntry.line2,
            'col2': csvEntry.col2
        }
    };
    if (csvEntry.text) {
        xmlEntry[input_format_1.contentKey] = csvEntry.text;
    }
    // check and recursively iterate children
    if (csvEntry.children && csvEntry.children.length > 0) {
        xmlEntry[input_format_1.childrenKey] = csvEntry.children
            // we sort children the same way xmlparsedata does (by line, by column, by inverse end line, by inverse end column, by terminal state, by combined "start" tiebreaker value)
            // (https://github.com/r-lib/xmlparsedata/blob/main/R/package.R#L153C72-L153C78)
            .sort((c1, c2) => c1.line1 - c2.line1 || c1.col1 - c2.col1 || c2.line2 - c1.line2 || c2.col2 - c1.col2 || Number(c1.terminal) - Number(c2.terminal) || sortTiebreak(c1) - sortTiebreak(c2))
            .map(convertEntry);
    }
    return xmlEntry;
}
function sortTiebreak(entry) {
    // see https://github.com/r-lib/xmlparsedata/blob/main/R/package.R#L110C5-L110C11
    return entry.line1 * (Math.max(entry.col1, entry.col2) + 1) + entry.col1;
}
//# sourceMappingURL=parser.js.map