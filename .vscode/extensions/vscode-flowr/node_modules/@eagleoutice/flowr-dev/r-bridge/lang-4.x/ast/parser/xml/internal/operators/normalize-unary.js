"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryNormalizeUnary = tryNormalizeUnary;
const parser_1 = require("../../../json/parser");
const normalize_meta_1 = require("../../normalize-meta");
const assert_1 = require("../../../../../../../util/assert");
const log_1 = require("../../../../../../../util/log");
const operators_1 = require("../../../../model/operators");
const normalize_single_node_1 = require("../structure/normalize-single-node");
/**
 * Parses the construct as a {@link RUnaryOp}.
 *
 * @param data     - The data used by the parser (see {@link NormalizerData})
 * @param operator - The operator token
 * @param operand  - The operand of the unary operator
 *
 * @returns The parsed {@link RUnaryOp} or `undefined` if the given construct is not a unary operator
 */
function tryNormalizeUnary(data, [operator, operand]) {
    (0, log_1.expensiveTrace)(parser_1.parseLog, () => `unary op for ${operator.name} ${operand.name}`);
    if (operators_1.UnaryOperatorsInRAst.has(operator.name)) {
        return parseUnaryOp(data, operator, operand);
    }
    else {
        return undefined;
    }
}
function parseUnaryOp(data, operator, operand) {
    const parsedOperand = (0, normalize_single_node_1.normalizeSingleNode)(data, operand);
    (0, assert_1.guard)(parsedOperand.type !== "RDelimiter" /* RType.Delimiter */, 'unexpected under-sided unary op');
    const operationName = (0, normalize_meta_1.retrieveOpName)(operator);
    const { location, content } = (0, normalize_meta_1.retrieveMetaStructure)(operator.content);
    return {
        type: "RUnaryOp" /* RType.UnaryOp */,
        location,
        operator: operationName,
        lexeme: content,
        operand: parsedOperand,
        info: {
            fullRange: data.currentRange,
            additionalTokens: [],
            fullLexeme: data.currentLexeme
        }
    };
}
//# sourceMappingURL=normalize-unary.js.map