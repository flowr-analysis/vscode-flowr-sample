"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RootId = void 0;
exports.prepareParsedData = prepareParsedData;
const retriever_1 = require("../../../../retriever");
const assert_1 = require("../../../../../util/assert");
exports.RootId = 0;
/**
 * Parses the given data and sets child relationship, return the list of root entries (with a parent of {@link RootId}).
 */
function prepareParsedData(data) {
    let json;
    try {
        json = JSON.parse(`[${data}]`);
    }
    catch (e) {
        throw new Error(`Failed to parse data ${data}: ${e?.message}`);
    }
    (0, assert_1.guard)(Array.isArray(json), () => `Expected ${data} to be an array but was not`);
    const ret = new Map(json.map(([line1, col1, line2, col2, id, parent, token, terminal, text]) => {
        return [id, { line1, col1, line2, col2, id, parent, token: (0, retriever_1.removeRQuotes)(token), terminal, text }];
    }));
    const roots = [];
    // iterate a second time to set parent-child relations (since they may be out of order in the csv)
    for (const entry of ret.values()) {
        if (entry.parent != exports.RootId) {
            /** it turns out that comments may return a negative id pair to their parent */
            const parent = ret.get(Math.abs(entry.parent));
            (0, assert_1.guard)(parent !== undefined, () => `Could not find parent ${entry.parent} for entry ${entry.id}`);
            parent.children ??= [];
            parent.children.push(entry);
        }
        else {
            roots.push(entry);
        }
    }
    return roots;
}
//# sourceMappingURL=format.js.map