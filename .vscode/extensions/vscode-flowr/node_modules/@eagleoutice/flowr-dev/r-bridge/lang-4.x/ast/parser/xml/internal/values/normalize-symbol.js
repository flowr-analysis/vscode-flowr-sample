"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryNormalizeSymbol = tryNormalizeSymbol;
const assert_1 = require("../../../../../../../util/assert");
const parser_1 = require("../../../json/parser");
const normalize_meta_1 = require("../../normalize-meta");
const strings_1 = require("../../../../../../../util/strings");
const type_1 = require("../../../../model/type");
/**
 * Normalize the given object as an R symbol (incorporating namespace information).
 * <p>
 * The special symbols `T` and `F` are parsed as logic values.
 *
 * @param data - The data used by the parser (see {@link NormalizerData})
 * @param objs - The json object to extract the meta-information from
 *
 * @returns The parsed symbol (with populated namespace information) or `undefined` if the given object is not a symbol.
 */
function tryNormalizeSymbol(data, objs) {
    (0, assert_1.guard)(objs.length > 0, 'to parse symbols we need at least one object to work on!');
    parser_1.parseLog.debug('trying to parse symbol');
    let location, content, namespace;
    if (objs.length === 1 && (0, type_1.isSymbol)(objs[0].name)) {
        const meta = (0, normalize_meta_1.retrieveMetaStructure)(objs[0].content);
        location = meta.location;
        content = meta.content;
        namespace = undefined;
    }
    else if (objs.length === 3 && (0, type_1.isSymbol)(objs[2].name)) {
        const meta = (0, normalize_meta_1.retrieveMetaStructure)(objs[2].content);
        location = meta.location;
        content = meta.content;
        namespace = (0, normalize_meta_1.retrieveMetaStructure)(objs[0].content).content;
    }
    else {
        return undefined;
    }
    return {
        type: "RSymbol" /* RType.Symbol */,
        namespace,
        location,
        // remove backticks from symbol
        content: (0, strings_1.startAndEndsWith)(content, '`') ? content.substring(1, content.length - 1) : content,
        lexeme: content,
        info: {
            fullRange: data.currentRange,
            additionalTokens: [],
            fullLexeme: data.currentLexeme
        }
    };
}
//# sourceMappingURL=normalize-symbol.js.map