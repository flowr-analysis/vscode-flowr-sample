"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryNormalizeWhile = tryNormalizeWhile;
const input_format_1 = require("../../input-format");
const parser_1 = require("../../../json/parser");
const normalize_meta_1 = require("../../normalize-meta");
const normalize_single_node_1 = require("../structure/normalize-single-node");
function tryNormalizeWhile(data, [whileToken, leftParen, condition, rightParen, body]) {
    if (whileToken.name !== "WHILE" /* RawRType.While */) {
        parser_1.parseLog.debug('encountered non-while token for supposed while-loop structure');
        return undefined;
    }
    else if (leftParen.name !== "(" /* RawRType.ParenLeft */) {
        throw new input_format_1.XmlParseError(`expected left-parenthesis for while but found ${JSON.stringify(leftParen)}`);
    }
    else if (rightParen.name !== ")" /* RawRType.ParenRight */) {
        throw new input_format_1.XmlParseError(`expected right-parenthesis for while but found ${JSON.stringify(rightParen)}`);
    }
    parser_1.parseLog.debug('trying to parse while-loop');
    const parsedCondition = (0, normalize_single_node_1.normalizeSingleNode)(data, condition);
    const parseBody = (0, normalize_single_node_1.normalizeSingleNode)(data, body);
    if (parsedCondition.type === "RDelimiter" /* RType.Delimiter */ || parseBody.type === "RDelimiter" /* RType.Delimiter */) {
        throw new input_format_1.XmlParseError(`unexpected under-sided while-loop, received ${JSON.stringify([
            parsedCondition,
            parseBody,
        ])} for ${JSON.stringify([whileToken, condition, body])}`);
    }
    const { location, content } = (0, normalize_meta_1.retrieveMetaStructure)(whileToken.content);
    return {
        type: "RWhileLoop" /* RType.WhileLoop */,
        condition: parsedCondition,
        body: (0, normalize_meta_1.ensureExpressionList)(parseBody),
        lexeme: content,
        location,
        info: {
            fullRange: data.currentRange,
            additionalTokens: [],
            fullLexeme: data.currentLexeme
        }
    };
}
//# sourceMappingURL=normalize-while.js.map