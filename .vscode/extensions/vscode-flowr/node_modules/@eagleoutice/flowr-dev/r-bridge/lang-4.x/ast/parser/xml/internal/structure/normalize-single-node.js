"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeSingleNode = normalizeSingleNode;
const normalize_meta_1 = require("../../normalize-meta");
const input_format_1 = require("../../input-format");
const normalize_line_directive_1 = require("../other/normalize-line-directive");
const assert_1 = require("../../../../../../../util/assert");
const normalize_delimiter_1 = require("./normalize-delimiter");
const normalize_comment_1 = require("../other/normalize-comment");
const normalize_expression_1 = require("../expression/normalize-expression");
const normalize_number_1 = require("../values/normalize-number");
const normalize_string_1 = require("../values/normalize-string");
const normalize_break_1 = require("../loops/normalize-break");
const normalize_next_1 = require("../loops/normalize-next");
const normalize_symbol_1 = require("../values/normalize-symbol");
/**
 * Parses a single structure in the ast based on its type (e.g., a string, a number, a symbol, ...)
 *
 * @param data - The data used by the parser (see {@link NormalizerData})
 * @param elem - The element to parse
 *
 * @returns The parsed element as an `RNode` or an `RDelimiter` if it is such.
 */
function normalizeSingleNode(data, elem) {
    switch (elem.name) {
        case "(" /* RawRType.ParenLeft */:
        case ")" /* RawRType.ParenRight */:
        case "{" /* RawRType.BraceLeft */:
        case "}" /* RawRType.BraceRight */:
            return (0, normalize_delimiter_1.normalizeDelimiter)(elem);
        case "COMMENT" /* RawRType.Comment */:
            return (0, normalize_comment_1.normalizeComment)(data, elem.content);
        case "LINE_DIRECTIVE" /* RawRType.LineDirective */:
            return (0, normalize_line_directive_1.normalizeLineDirective)(data, elem.content);
        case "exprlist" /* RawRType.ExpressionList */:
        case "expr" /* RawRType.Expression */:
        case "expr_or_assign_or_help" /* RawRType.ExprOfAssignOrHelp */:
        case "equal_assign" /* RawRType.LegacyEqualAssign */:
            return (0, normalize_expression_1.normalizeExpression)(data, elem.content);
        case "NUM_CONST" /* RawRType.NumericConst */:
            return (0, normalize_number_1.normalizeNumber)(data, elem.content);
        case "STR_CONST" /* RawRType.StringConst */:
            return (0, normalize_string_1.normalizeString)(data, elem.content);
        case "BREAK" /* RawRType.Break */:
            return (0, normalize_break_1.normalizeBreak)(data, elem.content);
        case "NEXT" /* RawRType.Next */:
            return (0, normalize_next_1.normalizeNext)(data, elem.content);
        case "SYMBOL" /* RawRType.Symbol */:
        case "SLOT" /* RawRType.Slot */:
        case "NULL_CONST" /* RawRType.NullConst */: {
            const symbol = (0, normalize_symbol_1.tryNormalizeSymbol)(data, (0, normalize_meta_1.getWithTokenType)([elem.content]));
            (0, assert_1.guard)(symbol !== undefined, () => `should have been parsed to a symbol but was ${JSON.stringify(symbol)}`);
            return symbol;
        }
        default:
            throw new input_format_1.XmlParseError(`unknown type ${elem.name} for ${JSON.stringify(elem)} in ${JSON.stringify(data)}`);
    }
}
//# sourceMappingURL=normalize-single-node.js.map