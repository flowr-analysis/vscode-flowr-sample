"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryNormalizeFunctionDefinition = tryNormalizeFunctionDefinition;
const parser_1 = require("../../../json/parser");
const normalize_meta_1 = require("../../normalize-meta");
const assert_1 = require("../../../../../../../util/assert");
const arrays_1 = require("../../../../../../../util/arrays");
const normalize_parameter_1 = require("./normalize-parameter");
const normalize_expressions_1 = require("../structure/normalize-expressions");
/**
 * Tries to parse the given data as a function definition.
 *
 * @param data - The data used by the parser (see {@link NormalizerData})
 * @param mappedWithName - The json object to extract the meta-information from
 *
 * @returns The parsed {@link RFunctionDefinition} or `undefined` if the given construct is not a function definition
 */
function tryNormalizeFunctionDefinition(data, mappedWithName) {
    const fnBase = mappedWithName[0];
    if (fnBase.name !== "FUNCTION" /* RawRType.Function */ && fnBase.name !== "\\\\" /* RawRType.Lambda */) {
        parser_1.parseLog.trace(`expected function definition to be identified by keyword, yet received ${fnBase.name}`);
        return undefined;
    }
    const { content, location } = (0, normalize_meta_1.retrieveMetaStructure)(fnBase.content);
    const openParen = mappedWithName[1];
    (0, assert_1.guard)(openParen.name === "(" /* RawRType.ParenLeft */, () => `expected opening parenthesis, yet received ${openParen.name}`);
    const closingParenIndex = mappedWithName.findIndex(x => x.name === ")" /* RawRType.ParenRight */);
    (0, assert_1.guard)(closingParenIndex !== -1, () => `expected closing parenthesis, yet received ${JSON.stringify(mappedWithName)}`);
    const splitParameters = (0, arrays_1.splitArrayOn)(mappedWithName.slice(2, closingParenIndex), x => x.name === "," /* RawRType.Comma */);
    parser_1.parseLog.trace(`function definition has ${splitParameters.length} parameters (by comma split)`);
    const parameters = splitParameters.map(x => (0, normalize_parameter_1.tryNormalizeParameter)(data, x));
    if (parameters.some(p => p === undefined)) {
        parser_1.parseLog.error(`function had unexpected unknown parameters: ${JSON.stringify(parameters.filter(assert_1.isNotUndefined))}, aborting.`);
        return undefined;
    }
    parser_1.parseLog.trace(`function definition retained ${parameters.length} parameters after parsing, moving to body.`);
    const bodyStructure = mappedWithName.slice(closingParenIndex + 1);
    (0, assert_1.guard)(bodyStructure.length === 1, () => `expected function body to be unique, yet received ${bodyStructure.length}`);
    const body = (0, normalize_expressions_1.normalizeExpressions)(data, bodyStructure);
    (0, assert_1.guard)(body.length === 1 && body[0].type !== "RDelimiter" /* RType.Delimiter */, () => `expected function body to yield one normalized expression, but ${body.length}`);
    return {
        type: "RFunctionDefinition" /* RType.FunctionDefinition */,
        location,
        lexeme: content,
        parameters: parameters,
        body: (0, normalize_meta_1.ensureExpressionList)(body[0]),
        info: {
            fullRange: data.currentRange,
            additionalTokens: [],
            fullLexeme: data.currentLexeme
        }
    };
}
//# sourceMappingURL=normalize-definition.js.map