"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeExpression = normalizeExpression;
const input_format_1 = require("../../input-format");
const parser_1 = require("../../../json/parser");
const normalize_meta_1 = require("../../normalize-meta");
const normalize_access_1 = require("../normalize-access");
const arrays_1 = require("../../../../../../../util/arrays");
const normalize_expressions_1 = require("../structure/normalize-expressions");
const normalize_call_1 = require("../functions/normalize-call");
const normalize_definition_1 = require("../functions/normalize-definition");
const normalize_comment_1 = require("../other/normalize-comment");
/**
 * Returns an expression list if there are multiple children, otherwise returns the single child directly with no expr wrapper
 *
 * @param data - The data used by the parser (see {@link NormalizerData})
 * @param obj  - The json object to extract the meta-information from
 */
function normalizeExpression(data, obj) {
    parser_1.parseLog.debug('[expr]');
    const { unwrappedObj, content, location } = (0, normalize_meta_1.retrieveMetaStructure)(obj);
    const childrenSource = (0, input_format_1.getKeyGuarded)(unwrappedObj, input_format_1.childrenKey);
    const typed = (0, normalize_meta_1.getWithTokenType)(childrenSource);
    const { others, comments } = (0, normalize_expressions_1.splitComments)(typed);
    const childData = { ...data, currentRange: location, currentLexeme: content };
    const maybeFunctionCall = (0, normalize_call_1.tryNormalizeFunctionCall)(childData, others);
    if (maybeFunctionCall !== undefined) {
        maybeFunctionCall.info.additionalTokens = [...maybeFunctionCall.info.additionalTokens ?? [], ...comments.map(x => (0, normalize_comment_1.normalizeComment)(data, x.content))];
        return maybeFunctionCall;
    }
    const maybeAccess = (0, normalize_access_1.tryNormalizeAccess)(childData, others);
    if (maybeAccess !== undefined) {
        maybeAccess.info.additionalTokens = [...maybeAccess.info.additionalTokens ?? [], ...comments.map(x => (0, normalize_comment_1.normalizeComment)(data, x.content))];
        return maybeAccess;
    }
    const maybeFunctionDefinition = (0, normalize_definition_1.tryNormalizeFunctionDefinition)(childData, others);
    if (maybeFunctionDefinition !== undefined) {
        maybeFunctionDefinition.info.additionalTokens = [...maybeFunctionDefinition.info.additionalTokens ?? [], ...comments.map(x => (0, normalize_comment_1.normalizeComment)(data, x.content))];
        return maybeFunctionDefinition;
    }
    const children = (0, normalize_expressions_1.normalizeExpressions)(childData, childrenSource);
    const [delimiters, nodes] = (0, arrays_1.partition)(children, x => x.type === "RDelimiter" /* RType.Delimiter */ || x.type === "RComment" /* RType.Comment */);
    if (nodes.length === 1) {
        const result = nodes[0];
        result.info.additionalTokens = [...result.info.additionalTokens ?? [], ...delimiters];
        return result;
    }
    else {
        return {
            type: "RExpressionList" /* RType.ExpressionList */,
            grouping: undefined,
            location,
            children: nodes,
            lexeme: content,
            info: {
                fullRange: childData.currentRange,
                additionalTokens: delimiters,
                fullLexeme: childData.currentLexeme
            }
        };
    }
}
//# sourceMappingURL=normalize-expression.js.map