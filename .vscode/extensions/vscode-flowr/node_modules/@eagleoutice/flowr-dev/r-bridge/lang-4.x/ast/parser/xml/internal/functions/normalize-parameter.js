"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryNormalizeParameter = tryNormalizeParameter;
const parser_1 = require("../../../json/parser");
const normalize_meta_1 = require("../../normalize-meta");
const assert_1 = require("../../../../../../../util/assert");
const normalize_single_node_1 = require("../structure/normalize-single-node");
/**
 * Either parses `[SYMBOL_FORMALS]` or `[SYMBOL_FORMALS, EQ_FORMALS, expr]` as a parameter of a function definition in R.
 * Probably directly called by the function definition parser as otherwise, we do not expect to find parameters.
 *
 * @param data - The data used by the parser (see {@link NormalizerData})
 * @param objs - Either `[SYMBOL_FORMALS]` or `[SYMBOL_FORMALS, EQ_FORMALS, expr]`
 *
 * @returns The parsed parameter or `undefined` if the given object is not a parameter.
 */
function tryNormalizeParameter(data, objs) {
    parser_1.parseLog.debug('[parameter]');
    if (objs.length !== 1 && objs.length !== 3) {
        parser_1.parseLog.warn(`Either [SYMBOL_FORMALS] or [SYMBOL_FORMALS, EQ_FORMALS, expr], but got: ${JSON.stringify(objs)}`);
        return undefined;
    }
    const symbol = objs[0];
    if (symbol.name !== "SYMBOL_FORMALS" /* RawRType.SymbolFormals */) {
        parser_1.parseLog.warn(`expected symbol for parameter, yet received ${JSON.stringify(objs)}`);
        return undefined;
    }
    const defaultValue = objs.length === 3 ? parseWithDefaultValue(data, objs) : undefined;
    const { location, content } = (0, normalize_meta_1.retrieveMetaStructure)(symbol.content);
    return {
        type: "RParameter" /* RType.Parameter */,
        location,
        special: content === '...',
        lexeme: content,
        name: {
            type: "RSymbol" /* RType.Symbol */,
            location, content,
            namespace: undefined,
            lexeme: content,
            info: {
                fullRange: location,
                additionalTokens: [],
                fullLexeme: content
            }
        },
        defaultValue: defaultValue?.type === "RDelimiter" /* RType.Delimiter */ ? undefined : defaultValue,
        info: {
            fullRange: location,
            fullLexeme: content,
            additionalTokens: defaultValue?.type === "RDelimiter" /* RType.Delimiter */ ? [defaultValue] : []
        }
    };
}
function parseWithDefaultValue(data, objs) {
    (0, assert_1.guard)(objs[1].name === "EQ_FORMALS" /* RawRType.EqualFormals */, () => `[arg-default] second element of parameter must be ${"EQ_FORMALS" /* RawRType.EqualFormals */}, but: ${JSON.stringify(objs)}`);
    (0, assert_1.guard)(objs[2].name === "expr" /* RawRType.Expression */, () => `[arg-default] third element of parameter must be an Expression but: ${JSON.stringify(objs)}`);
    return (0, normalize_single_node_1.normalizeSingleNode)(data, objs[2]);
}
//# sourceMappingURL=normalize-parameter.js.map