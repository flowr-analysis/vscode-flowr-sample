"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryToNormalizeArgument = tryToNormalizeArgument;
const parser_1 = require("../../../json/parser");
const normalize_meta_1 = require("../../normalize-meta");
const assert_1 = require("../../../../../../../util/assert");
const normalize_single_node_1 = require("../structure/normalize-single-node");
/**
 * Either parses `[expr]` or `[SYMBOL_SUB, EQ_SUB, expr]` as an argument of a function call in R.
 * Probably directly called by the function call parser as otherwise, we do not expect to find arguments.
 *
 * @param data - The data used by the parser (see {@link NormalizerData})
 * @param objs - Either `[expr]` or `[SYMBOL_FORMALS, EQ_FORMALS, expr]`
 *
 * @returns The parsed argument or `undefined` if the given object is not an argument.
 */
function tryToNormalizeArgument(data, objs) {
    parser_1.parseLog.debug('[argument]');
    if (objs.length < 1 || objs.length > 3) {
        parser_1.parseLog.warn(`Either [expr|value], [SYMBOL_SUB, EQ_SUB], or [SYMBOL_SUB, EQ_SUB, expr], but got: ${objs.map(o => o.name).join(', ')}`);
        return undefined;
    }
    const symbolOrExpr = objs[0];
    const { location, content } = (0, normalize_meta_1.retrieveMetaStructure)(symbolOrExpr.content);
    let parsedValue;
    let name;
    if (symbolOrExpr.name === "expr" /* RawRType.Expression */) {
        name = undefined;
        parsedValue = (0, normalize_single_node_1.normalizeSingleNode)(data, symbolOrExpr);
    }
    else if (symbolOrExpr.name === "SYMBOL_SUB" /* RawRType.SymbolSub */ || symbolOrExpr.name === "STR_CONST" /* RawRType.StringConst */) {
        name = {
            type: "RSymbol" /* RType.Symbol */,
            location,
            content: symbolOrExpr.name === "STR_CONST" /* RawRType.StringConst */ ? content.slice(1, -1) : content,
            namespace: undefined,
            lexeme: content,
            info: {
                fullRange: location,
                additionalTokens: [],
                fullLexeme: content
            }
        };
        parsedValue = parseWithValue(data, objs);
    }
    else {
        parser_1.parseLog.warn(`expected symbol or expr for argument, yet received ${objs.map(o => o.name).join(',')}`);
        return undefined;
    }
    (0, assert_1.guard)(parsedValue !== undefined && parsedValue?.type !== "RDelimiter" /* RType.Delimiter */, () => `[argument] parsed value must not be undefined, yet: ${JSON.stringify(objs)}`);
    return {
        type: "RArgument" /* RType.Argument */,
        location,
        lexeme: content,
        name,
        value: parsedValue ?? undefined,
        info: {
            fullRange: location,
            fullLexeme: content,
            additionalTokens: []
        }
    };
}
function parseWithValue(data, objs) {
    (0, assert_1.guard)(objs[1].name === "EQ_SUB" /* RawRType.EqualSub */, () => `[arg-default] second element of parameter must be ${"EQ_FORMALS" /* RawRType.EqualFormals */}, but: ${JSON.stringify(objs)}`);
    (0, assert_1.guard)(objs.length === 2 || objs[2].name === "expr" /* RawRType.Expression */, () => `[arg-default] third element of parameter must be an Expression or undefined (for 'x=') but: ${JSON.stringify(objs)}`);
    return objs[2] ? (0, normalize_single_node_1.normalizeSingleNode)(data, objs[2]) : null;
}
//# sourceMappingURL=normalize-argument.js.map