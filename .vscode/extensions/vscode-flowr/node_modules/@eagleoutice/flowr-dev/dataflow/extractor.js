"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processors = void 0;
exports.produceDataFlowGraph = produceDataFlowGraph;
const processor_1 = require("./processor");
const process_uninteresting_leaf_1 = require("./internal/process/process-uninteresting-leaf");
const process_symbol_1 = require("./internal/process/process-symbol");
const default_call_handling_1 = require("./internal/process/functions/call/default-call-handling");
const process_parameter_1 = require("./internal/process/functions/process-parameter");
const process_argument_1 = require("./internal/process/functions/process-argument");
const process_named_call_1 = require("./internal/process/process-named-call");
const process_value_1 = require("./internal/process/process-value");
const named_call_handling_1 = require("./internal/process/functions/call/named-call-handling");
const make_argument_1 = require("./internal/process/functions/call/argument/make-argument");
const range_1 = require("../util/range");
const retriever_1 = require("../r-bridge/retriever");
const environment_1 = require("./environments/environment");
const built_in_source_1 = require("./internal/process/functions/call/built-in/built-in-source");
exports.processors = {
    ["RNumber" /* RType.Number */]: process_value_1.processValue,
    ["RString" /* RType.String */]: process_value_1.processValue,
    ["RLogical" /* RType.Logical */]: process_value_1.processValue,
    ["RComment" /* RType.Comment */]: process_uninteresting_leaf_1.processUninterestingLeaf,
    ["RLineDirective" /* RType.LineDirective */]: process_uninteresting_leaf_1.processUninterestingLeaf,
    ["RSymbol" /* RType.Symbol */]: process_symbol_1.processSymbol,
    ["RAccess" /* RType.Access */]: (n, d) => (0, process_named_call_1.processAsNamedCall)(n, d, n.operator, [n.accessed, ...n.access]),
    ["RBinaryOp" /* RType.BinaryOp */]: (n, d) => (0, process_named_call_1.processAsNamedCall)(n, d, n.operator, [n.lhs, n.rhs]),
    ["RPipe" /* RType.Pipe */]: (n, d) => (0, process_named_call_1.processAsNamedCall)(n, d, n.lexeme, [n.lhs, n.rhs]),
    ["RUnaryOp" /* RType.UnaryOp */]: (n, d) => (0, process_named_call_1.processAsNamedCall)(n, d, n.operator, [n.operand]),
    ["RForLoop" /* RType.ForLoop */]: (n, d) => (0, process_named_call_1.processAsNamedCall)(n, d, n.lexeme, [n.variable, n.vector, n.body]),
    ["RWhileLoop" /* RType.WhileLoop */]: (n, d) => (0, process_named_call_1.processAsNamedCall)(n, d, n.lexeme, [n.condition, n.body]),
    ["RRepeatLoop" /* RType.RepeatLoop */]: (n, d) => (0, process_named_call_1.processAsNamedCall)(n, d, n.lexeme, [n.body]),
    ["RIfThenElse" /* RType.IfThenElse */]: (n, d) => (0, process_named_call_1.processAsNamedCall)(n, d, n.lexeme, [n.condition, n.then, n.otherwise]),
    ["RBreak" /* RType.Break */]: (n, d) => (0, process_named_call_1.processAsNamedCall)(n, d, n.lexeme, []),
    ["RNext" /* RType.Next */]: (n, d) => (0, process_named_call_1.processAsNamedCall)(n, d, n.lexeme, []),
    ["RFunctionCall" /* RType.FunctionCall */]: default_call_handling_1.processFunctionCall,
    ["RFunctionDefinition" /* RType.FunctionDefinition */]: (n, d) => (0, process_named_call_1.processAsNamedCall)(n, d, n.lexeme, [...n.parameters, n.body]),
    ["RParameter" /* RType.Parameter */]: process_parameter_1.processFunctionParameter,
    ["RArgument" /* RType.Argument */]: process_argument_1.processFunctionArgument,
    ["RExpressionList" /* RType.ExpressionList */]: (n, d) => (0, named_call_handling_1.processNamedCall)({
        type: "RSymbol" /* RType.Symbol */,
        info: n.info,
        content: n.grouping?.[0].content ?? '{',
        lexeme: n.grouping?.[0].lexeme ?? '{',
        location: n.location ?? (0, range_1.rangeFrom)(-1, -1, -1, -1),
        namespace: n.grouping?.[0].content ? undefined : 'base'
    }, (0, make_argument_1.wrapArgumentsUnnamed)(n.children, d.completeAst.idMap), n.info.id, d)
};
function produceDataFlowGraph(request, ast) {
    const multifile = Array.isArray(request);
    let firstRequest;
    if (multifile) {
        firstRequest = request[0];
    }
    else {
        firstRequest = request;
    }
    const dfData = {
        completeAst: ast,
        environment: (0, environment_1.initializeCleanEnvironments)(),
        processors: exports.processors,
        currentRequest: firstRequest,
        controlDependencies: undefined,
        referenceChain: [(0, retriever_1.requestFingerprint)(firstRequest)]
    };
    let df = (0, processor_1.processDataflowFor)(ast.ast, dfData);
    if (multifile) {
        for (let i = 1; i < request.length; i++) {
            df = (0, built_in_source_1.standaloneSourceFile)(request[i], dfData, `root-${i}`, df);
        }
    }
    return df;
}
//# sourceMappingURL=extractor.js.map