"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.define = define;
const assert_1 = require("../../util/assert");
const environment_1 = require("./environment");
const clone_1 = require("./clone");
function defInEnv(newEnvironments, name, definition) {
    const existing = newEnvironments.memory.get(name);
    // check if it is maybe or not
    if (existing === undefined || definition.controlDependencies === undefined) {
        newEnvironments.memory.set(name, [definition]);
    }
    else {
        existing.push(definition);
    }
}
/**
 * Insert the given `definition` --- defined within the given scope --- into the passed along `environments` will take care of propagation.
 * Does not modify the passed along `environments` in-place! It returns the new reference.
 */
function define(definition, superAssign, environment) {
    const name = definition.name;
    (0, assert_1.guard)(name !== undefined, () => `Name must be defined, but isn't for ${JSON.stringify(definition)}`);
    let newEnvironment;
    if (superAssign) {
        newEnvironment = (0, clone_1.cloneEnvironmentInformation)(environment, true);
        let current = newEnvironment.current;
        let last = undefined;
        let found = false;
        do {
            if (current.memory.has(name)) {
                current.memory.set(name, [definition]);
                found = true;
                break;
            }
            last = current;
            current = current.parent;
        } while (current.id !== environment_1.BuiltInEnvironment.id);
        if (!found) {
            (0, assert_1.guard)(last !== undefined, () => `Could not find global scope for ${name}`);
            last.memory.set(name, [definition]);
        }
    }
    else {
        newEnvironment = (0, clone_1.cloneEnvironmentInformation)(environment, false);
        defInEnv(newEnvironment.current, name, definition);
    }
    return newEnvironment;
}
//# sourceMappingURL=define.js.map