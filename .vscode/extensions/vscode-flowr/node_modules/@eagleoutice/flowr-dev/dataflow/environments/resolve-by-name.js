"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveByName = resolveByName;
exports.resolvesToBuiltInConstant = resolvesToBuiltInConstant;
const environment_1 = require("./environment");
const identifier_1 = require("./identifier");
const info_1 = require("../info");
const FunctionTargetTypes = 2 /* ReferenceType.Function */ | 128 /* ReferenceType.BuiltInFunction */ | 1 /* ReferenceType.Unknown */ | 32 /* ReferenceType.Argument */ | 16 /* ReferenceType.Parameter */;
const VariableTargetTypes = 4 /* ReferenceType.Variable */ | 16 /* ReferenceType.Parameter */ | 32 /* ReferenceType.Argument */ | 1 /* ReferenceType.Unknown */;
const ConstantTargetTypes = 8 /* ReferenceType.Constant */ | 64 /* ReferenceType.BuiltInConstant */ | 1 /* ReferenceType.Unknown */;
const BuiltInConstantTargetTypes = 64 /* ReferenceType.BuiltInConstant */ | 1 /* ReferenceType.Unknown */;
const BuiltInFunctionTargetTypes = 128 /* ReferenceType.BuiltInFunction */ | 1 /* ReferenceType.Unknown */;
const TargetTypePredicate = {
    [1 /* ReferenceType.Unknown */]: () => true,
    [2 /* ReferenceType.Function */]: ({ type }) => (0, identifier_1.isReferenceType)(type, FunctionTargetTypes),
    [4 /* ReferenceType.Variable */]: ({ type }) => (0, identifier_1.isReferenceType)(type, VariableTargetTypes),
    [8 /* ReferenceType.Constant */]: ({ type }) => (0, identifier_1.isReferenceType)(type, ConstantTargetTypes),
    [16 /* ReferenceType.Parameter */]: () => true,
    [32 /* ReferenceType.Argument */]: () => true,
    [64 /* ReferenceType.BuiltInConstant */]: ({ type }) => (0, identifier_1.isReferenceType)(type, BuiltInConstantTargetTypes),
    [128 /* ReferenceType.BuiltInFunction */]: ({ type }) => (0, identifier_1.isReferenceType)(type, BuiltInFunctionTargetTypes)
};
/**
 * Resolves a given identifier name to a list of its possible definition location using R scoping and resolving rules.
 *
 * @param name         - The name of the identifier to resolve
 * @param environment  - The current environment used for name resolution
 * @param target       - The target (meta) type of the identifier to resolve
 *
 * @returns A list of possible definitions of the identifier (one if the definition location is exactly and always known), or `undefined` if the identifier is undefined in the current scope/with the current environment information.
 */
function resolveByName(name, environment, target = 1 /* ReferenceType.Unknown */) {
    let current = environment.current;
    let definitions = undefined;
    const wantedType = TargetTypePredicate[target];
    do {
        const definition = current.memory.get(name);
        if (definition !== undefined) {
            const filtered = definition.filter(wantedType);
            if (filtered.length === definition.length && definition.every(d => (0, info_1.happensInEveryBranch)(d.controlDependencies))) {
                return definition;
            }
            else if (filtered.length > 0) {
                definitions ??= [];
                definitions.push(...filtered);
            }
        }
        current = current.parent;
    } while (current.id !== environment_1.BuiltInEnvironment.id);
    const builtIns = current.memory.get(name);
    if (definitions) {
        return builtIns === undefined ? definitions : [...definitions, ...builtIns];
    }
    else {
        return builtIns;
    }
}
function resolvesToBuiltInConstant(name, environment, wantedValue) {
    if (name === undefined) {
        return 2 /* Ternary.Never */;
    }
    const definition = resolveByName(name, environment, 8 /* ReferenceType.Constant */);
    if (definition === undefined) {
        return 2 /* Ternary.Never */;
    }
    let all = true;
    let some = false;
    for (const def of definition) {
        if (def.type === 64 /* ReferenceType.BuiltInConstant */ && def.value === wantedValue) {
            some = true;
        }
        else {
            all = false;
        }
    }
    if (all) {
        return 0 /* Ternary.Always */;
    }
    else {
        return some ? 1 /* Ternary.Maybe */ : 2 /* Ternary.Never */;
    }
}
//# sourceMappingURL=resolve-by-name.js.map