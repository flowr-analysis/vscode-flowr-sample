"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processLibrary = processLibrary;
const known_call_handling_1 = require("../known-call-handling");
const logger_1 = require("../../../../../logger");
const unpack_argument_1 = require("../argument/unpack-argument");
const make_argument_1 = require("../argument/make-argument");
function processLibrary(name, args, rootId, data) {
    /* we do not really know what loading the library does and what side effects it causes, hence we mark it as an unknown side effect */
    if (args.length !== 1) {
        logger_1.dataflowLogger.warn(`Currently only one-arg library-likes are allows (for ${name.content}), skipping`);
        return (0, known_call_handling_1.processKnownFunctionCall)({ name, args, rootId, data, hasUnknownSideEffect: true }).information;
    }
    const nameToLoad = (0, unpack_argument_1.unpackArgument)(args[0]);
    if (nameToLoad === undefined || nameToLoad.type !== "RSymbol" /* RType.Symbol */) {
        logger_1.dataflowLogger.warn('No library name provided, skipping');
        return (0, known_call_handling_1.processKnownFunctionCall)({ name, args, rootId, data, hasUnknownSideEffect: true }).information;
    }
    // treat as a function call but convert the first argument to a string
    const newArg = {
        type: "RString" /* RType.String */,
        info: nameToLoad.info,
        lexeme: nameToLoad.lexeme,
        location: nameToLoad.location,
        content: {
            quotes: 'none',
            str: nameToLoad.content
        }
    };
    return (0, known_call_handling_1.processKnownFunctionCall)({
        name, args: (0, make_argument_1.wrapArgumentsUnnamed)([newArg], data.completeAst.idMap), rootId, data,
        hasUnknownSideEffect: true
    }).information;
}
//# sourceMappingURL=built-in-library.js.map