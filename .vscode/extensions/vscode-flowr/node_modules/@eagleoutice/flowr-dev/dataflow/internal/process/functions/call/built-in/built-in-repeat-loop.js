"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processRepeatLoop = processRepeatLoop;
const info_1 = require("../../../../../info");
const linker_1 = require("../../../../linker");
const known_call_handling_1 = require("../known-call-handling");
const assert_1 = require("../../../../../../util/assert");
const unpack_argument_1 = require("../argument/unpack-argument");
const r_function_call_1 = require("../../../../../../r-bridge/lang-4.x/ast/model/nodes/r-function-call");
const logger_1 = require("../../../../../logger");
function processRepeatLoop(name, args, rootId, data) {
    if (args.length !== 1 || args[0] === r_function_call_1.EmptyArgument) {
        logger_1.dataflowLogger.warn(`Repeat-Loop ${name.content} does not have 1 argument, skipping`);
        return (0, known_call_handling_1.processKnownFunctionCall)({ name, args, rootId, data }).information;
    }
    const unpacked = (0, unpack_argument_1.unpackArgument)(args[0]);
    const { information, processedArguments } = (0, known_call_handling_1.processKnownFunctionCall)({
        name,
        args: unpacked ? [unpacked] : args,
        rootId,
        data,
        patchData: (d, i) => {
            if (i === 0) {
                return { ...d, controlDependencies: [...d.controlDependencies ?? [], { id: name.info.id }] };
            }
            return d;
        },
        markAsNSE: [0]
    });
    const body = processedArguments[0];
    (0, assert_1.guard)(body !== undefined, () => `Repeat-Loop ${name.content} has no body, impossible!`);
    (0, linker_1.linkCircularRedefinitionsWithinALoop)(information.graph, (0, linker_1.produceNameSharedIdMap)((0, linker_1.findNonLocalReads)(information.graph)), body.out);
    information.exitPoints = (0, info_1.filterOutLoopExitPoints)(information.exitPoints);
    return information;
}
//# sourceMappingURL=built-in-repeat-loop.js.map