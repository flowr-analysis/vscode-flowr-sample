"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processAssignment = processAssignment;
exports.markAsAssignment = markAsAssignment;
const known_call_handling_1 = require("../known-call-handling");
const assert_1 = require("../../../../../../util/assert");
const log_1 = require("../../../../../../util/log");
const unpack_argument_1 = require("../argument/unpack-argument");
const process_named_call_1 = require("../../../process-named-call");
const make_argument_1 = require("../argument/make-argument");
const logger_1 = require("../../../../../logger");
const overwrite_1 = require("../../../../../environments/overwrite");
const retriever_1 = require("../../../../../../r-bridge/retriever");
const vertex_1 = require("../../../../../graph/vertex");
const define_1 = require("../../../../../environments/define");
const edge_1 = require("../../../../../graph/edge");
function toReplacementSymbol(target, prefix, superAssignment) {
    return {
        type: "RSymbol" /* RType.Symbol */,
        info: target.info,
        /* they are all mapped to `<-` in R, but we mark super as well */
        content: `${prefix}${superAssignment ? '<<-' : '<-'}`,
        lexeme: target.lexeme,
        location: target.location,
        namespace: undefined
    };
}
function getEffectiveOrder(config, args) {
    return config.swapSourceAndTarget ? [args[1], args[0]] : args;
}
function findRootAccess(node) {
    let current = node;
    while (current.type === "RAccess" /* RType.Access */) {
        current = current.accessed;
    }
    if (current.type === "RSymbol" /* RType.Symbol */) {
        return current;
    }
    else {
        return undefined;
    }
}
/**
 * Processes an assignment, i.e., `<target> <- <source>`.
 * Handling it as a function call \`&lt;-\` `(<target>, <source>)`.
 * This includes handling of replacement functions (e.g., `names(x) <- ...` as \`names&lt;-\` `(x, ...)`).
 */
function processAssignment(name, 
/* we expect them to be ordered in the sense that we have (source, target): `<source> <- <target>` */
args, rootId, data, config) {
    if (args.length != 2) {
        logger_1.dataflowLogger.warn(`Assignment ${name.content} has something else than 2 arguments, skipping`);
        return (0, known_call_handling_1.processKnownFunctionCall)({ name, args, rootId, data, forceArgs: config.forceArgs }).information;
    }
    const effectiveArgs = getEffectiveOrder(config, args);
    const { target, source } = extractSourceAndTarget(effectiveArgs, name);
    const { type, named } = target;
    if (type === "RSymbol" /* RType.Symbol */) {
        const res = (0, known_call_handling_1.processKnownFunctionCall)({ name, args, rootId, data, reverseOrder: !config.swapSourceAndTarget, forceArgs: config.forceArgs });
        return processAssignmentToSymbol({
            ...config,
            nameOfAssignmentFunction: name.content,
            source,
            target,
            args: getEffectiveOrder(config, res.processedArguments),
            rootId,
            data,
            information: res.information,
        });
    }
    else if (config.canBeReplacement && type === "RFunctionCall" /* RType.FunctionCall */ && named) {
        /* as replacement functions take precedence over the lhs fn-call (i.e., `names(x) <- ...` is independent from the definition of `names`), we do not have to process the call */
        logger_1.dataflowLogger.debug(`Assignment ${name.content} has a function call as target => replacement function ${target.lexeme}`);
        const replacement = toReplacementSymbol(target, target.functionName.content, config.superAssignment ?? false);
        return (0, process_named_call_1.processAsNamedCall)(replacement, data, replacement.content, [...target.arguments, source]);
    }
    else if (config.canBeReplacement && type === "RAccess" /* RType.Access */) {
        logger_1.dataflowLogger.debug(`Assignment ${name.content} has an access as target => replacement function ${target.lexeme}`);
        const replacement = toReplacementSymbol(target, target.operator, config.superAssignment ?? false);
        return (0, process_named_call_1.processAsNamedCall)(replacement, data, replacement.content, [(0, make_argument_1.toUnnamedArgument)(target.accessed, data.completeAst.idMap), ...target.access, source]);
    }
    else if (type === "RAccess" /* RType.Access */) {
        const rootArg = findRootAccess(target);
        if (rootArg) {
            const res = (0, known_call_handling_1.processKnownFunctionCall)({
                name,
                args: [rootArg, source],
                rootId,
                data,
                reverseOrder: !config.swapSourceAndTarget,
                forceArgs: config.forceArgs
            });
            return processAssignmentToSymbol({
                ...config,
                nameOfAssignmentFunction: name.content,
                source,
                target: rootArg,
                args: getEffectiveOrder(config, res.processedArguments),
                rootId,
                data,
                information: res.information,
            });
        }
    }
    else if (type === "RString" /* RType.String */) {
        return processAssignmentToString(target, args, name, rootId, data, config, source);
    }
    logger_1.dataflowLogger.warn(`Assignment ${name.content} has an unknown target type ${target.type}, skipping`);
    return (0, known_call_handling_1.processKnownFunctionCall)({ name, args: effectiveArgs, rootId, data, forceArgs: config.forceArgs }).information;
}
function extractSourceAndTarget(args, name) {
    const source = (0, unpack_argument_1.unpackArgument)(args[1]);
    const target = (0, unpack_argument_1.unpackArgument)(args[0]);
    (0, assert_1.guard)(source !== undefined, () => `Assignment ${name.content} has no source, impossible!`);
    (0, assert_1.guard)(target !== undefined, () => `Assignment ${name.content} has no target, impossible!`);
    return { source, target };
}
function produceWrittenNodes(rootId, target, referenceType, data, makeMaybe) {
    return [...target.in, ...target.unknownReferences].map(ref => ({
        ...ref,
        type: referenceType,
        definedAt: rootId,
        controlDependencies: data.controlDependencies ?? (makeMaybe ? [] : undefined)
    }));
}
function processAssignmentToString(target, args, name, rootId, data, config, source) {
    const symbol = {
        type: "RSymbol" /* RType.Symbol */,
        info: target.info,
        content: (0, retriever_1.removeRQuotes)(target.lexeme),
        lexeme: target.lexeme,
        location: target.location,
        namespace: undefined
    };
    // treat first argument to Symbol
    const mappedArgs = config.swapSourceAndTarget ? [args[0], {
            ...args[1],
            value: symbol
        }] : [{ ...args[0], value: symbol }, args[1]];
    const res = (0, known_call_handling_1.processKnownFunctionCall)({
        name,
        args: mappedArgs,
        rootId,
        data,
        reverseOrder: !config.swapSourceAndTarget,
        forceArgs: config.forceArgs
    });
    return processAssignmentToSymbol({
        ...config,
        nameOfAssignmentFunction: name.content,
        source,
        target: symbol,
        args: getEffectiveOrder(config, res.processedArguments),
        rootId,
        data,
        information: res.information
    });
}
function checkTargetReferenceType(source, sourceInfo) {
    const vert = sourceInfo.graph.getVertex(source.info.id, true);
    switch (vert?.tag) {
        case vertex_1.VertexType.FunctionDefinition:
            return 2 /* ReferenceType.Function */;
        case vertex_1.VertexType.Use:
        case vertex_1.VertexType.FunctionCall:
            return 1 /* ReferenceType.Unknown */;
        default:
            return 4 /* ReferenceType.Variable */;
    }
}
/**
 * Consider a call like `x <- v`
 * @param information        - the information to define the assignment within
 * @param nodeToDefine       - `x`
 * @param sourceIds          - `v`
 * @param rootIdOfAssignment - `<-`
 * @param quoteSource        - whether to quote the source (i.e., define `x` without a direct reference to `v`)
 * @param superAssignment    - whether this is a super assignment (i.e., `<<-`)
 */
function markAsAssignment(information, nodeToDefine, sourceIds, rootIdOfAssignment, quoteSource, superAssignment) {
    information.environment = (0, define_1.define)(nodeToDefine, superAssignment, information.environment);
    information.graph.setDefinitionOfVertex(nodeToDefine);
    if (!quoteSource) {
        for (const sourceId of sourceIds) {
            information.graph.addEdge(nodeToDefine, sourceId, { type: edge_1.EdgeType.DefinedBy });
        }
    }
    information.graph.addEdge(nodeToDefine, rootIdOfAssignment, { type: edge_1.EdgeType.DefinedBy });
    // kinda dirty, but we have to remove existing read edges for the symbol, added by the child
    const out = information.graph.outgoingEdges(nodeToDefine.nodeId);
    for (const [id, edge] of (out ?? [])) {
        edge.types &= ~edge_1.EdgeType.Reads;
        if (edge.types == 0) {
            out?.delete(id);
        }
    }
}
/**
 * Helper function whenever it is known that the _target_ of an assignment is a (single) symbol (i.e. `x <- ...`, but not `names(x) <- ...`).
 */
function processAssignmentToSymbol({ nameOfAssignmentFunction, source, args: [targetArg, sourceArg], target, rootId, data, information, superAssignment, makeMaybe, quoteSource }) {
    const referenceType = checkTargetReferenceType(source, sourceArg);
    const writeNodes = produceWrittenNodes(rootId, targetArg, referenceType, data, makeMaybe ?? false);
    if (writeNodes.length !== 1 && log_1.log.settings.minLevel <= 4 /* LogLevel.Warn */) {
        log_1.log.warn(`Unexpected write number in assignment: ${JSON.stringify(writeNodes)}`);
    }
    // we drop the first arg which we use to pass along arguments :D
    const readFromSourceWritten = sourceArg.out.slice(1);
    const readTargets = [
        { nodeId: rootId, name: nameOfAssignmentFunction, controlDependencies: data.controlDependencies, type: 2 /* ReferenceType.Function */ },
        ...sourceArg.unknownReferences, ...sourceArg.in, ...targetArg.in.filter(i => i.nodeId !== target.info.id), ...readFromSourceWritten
    ];
    information.environment = (0, overwrite_1.overwriteEnvironment)(targetArg.environment, sourceArg.environment);
    // install assigned variables in environment
    for (const write of writeNodes) {
        markAsAssignment(information, write, [source.info.id], rootId, quoteSource, superAssignment);
    }
    information.graph.addEdge(rootId, targetArg.entryPoint, { type: edge_1.EdgeType.Returns });
    if (quoteSource) {
        information.graph.addEdge(rootId, source.info.id, { type: edge_1.EdgeType.NonStandardEvaluation });
    }
    return {
        ...information,
        unknownReferences: [],
        entryPoint: rootId,
        in: readTargets,
        out: [...writeNodes, ...readFromSourceWritten]
    };
}
//# sourceMappingURL=built-in-assignment.js.map