"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileMigrator = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const assert_1 = require("../../../util/assert");
class FileMigrator {
    writeHandles = new Map();
    finished = false;
    async migrate(sourceFolderContent, targetFolder, originalFile) {
        (0, assert_1.guard)(!this.finished, () => 'migrator is already marked as finished!');
        if (!fs_1.default.existsSync(targetFolder)) {
            fs_1.default.mkdirSync(targetFolder, { recursive: true });
        }
        const promises = [];
        for (const [filepath, content] of sourceFolderContent.entries()) {
            const target = path_1.default.join(targetFolder, filepath);
            let targetStream = this.writeHandles.get(target);
            if (targetStream === undefined) {
                if (!fs_1.default.existsSync(path_1.default.dirname(target))) {
                    fs_1.default.mkdirSync(path_1.default.dirname(target), { recursive: true });
                }
                targetStream = fs_1.default.createWriteStream(target, { flags: 'a' });
                this.writeHandles.set(target, targetStream);
            }
            // before we write said content we have to group {value: string, context: string} by context (while we can safely assume that there is only one context per file,
            // i want to be sure
            let data;
            // regex matches failed due to encoding errors
            if (filepath.endsWith('meta/stats.txt') || filepath.endsWith('meta/features.txt')) {
                data = `{"file":"${originalFile ?? ''}","content":${content.trimEnd()}}\n`;
            }
            else {
                const grouped = groupByContext(content);
                data = grouped === undefined ? content : grouped.map(s => JSON.stringify(s)).join('\n') + '\n';
            }
            promises.push(new Promise((resolve, reject) => targetStream.write(data, 'utf-8', err => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            })));
        }
        await Promise.all(promises);
    }
    finish() {
        for (const handle of this.writeHandles.values()) {
            handle.close();
        }
        this.finished = true;
    }
}
exports.FileMigrator = FileMigrator;
function groupByContext(input) {
    if (input === undefined) {
        return [];
    }
    const parsed = input.split('\n').filter(s => s && s !== '').map(s => JSON.parse(s));
    const grouped = new Map();
    for (const content of parsed) {
        if (!Array.isArray(content)) {
            // in this case it is a meta file or other which does not have to be grouped
            return undefined;
        }
        const [value, context] = content;
        const get = grouped.get(context);
        if (get === undefined) {
            grouped.set(context, [value]);
        }
        else {
            get.push(value);
        }
    }
    return [...grouped.entries()].map(([context, values]) => [values, context]);
}
//# sourceMappingURL=process.js.map