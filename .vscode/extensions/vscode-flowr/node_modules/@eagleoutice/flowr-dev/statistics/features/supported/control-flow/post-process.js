"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.postProcess = postProcess;
const common_syntax_probability_1 = require("../../common-syntax-probability");
const post_processing_1 = require("../../post-processing");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const summarizer_1 = require("../../../../util/summarizer");
function postProcess(featureRoot, info, outputPath, config) {
    const collected = {
        ifThen: (0, common_syntax_probability_1.emptyCommonSyntaxTypeCounts)(() => []),
        thenBody: (0, common_syntax_probability_1.emptyCommonSyntaxTypeCounts)(() => []),
        ifThenElse: (0, common_syntax_probability_1.emptyCommonSyntaxTypeCounts)(() => []),
        elseBody: (0, common_syntax_probability_1.emptyCommonSyntaxTypeCounts)(() => []),
        nestedIfThen: (0, post_processing_1.emptySummarizedWithProject)(),
        nestedIfThenElse: (0, post_processing_1.emptySummarizedWithProject)(),
        deepestNesting: (0, post_processing_1.emptySummarizedWithProject)(),
        switchCase: (0, common_syntax_probability_1.emptyCommonSyntaxTypeCounts)(() => [])
    };
    for (const [filepath, data] of info.entries()) {
        const value = data.controlflow;
        for (const [key, val] of Object.entries(value)) {
            if (typeof val === 'object') {
                (0, common_syntax_probability_1.appendCommonSyntaxTypeCounter)(collected[key], val);
            }
            else {
                const get = collected[key];
                get.count.push(val);
                if (val > 0) {
                    (0, post_processing_1.recordFilePath)(get, filepath, config);
                }
            }
        }
    }
    const metaOut = fs_1.default.createWriteStream(path_1.default.join(outputPath, 'control-flow-meta.csv'));
    metaOut.write(`kind,unique-projects,unique-files,${(0, summarizer_1.summarizedMeasurement2CsvHeader)()}\n`);
    for (const [key, val] of Object.entries(collected)) {
        const data = val;
        if ('uniqueProjects' in data) {
            metaOut.write(`${JSON.stringify(key)},${data.uniqueProjects.size},${data.uniqueFiles.size},${(0, summarizer_1.summarizedMeasurement2Csv)((0, summarizer_1.summarizeMeasurement)(data.count))}\n`);
        }
        else {
            const out = fs_1.default.createWriteStream(path_1.default.join(outputPath, `control-flow-type-${key}.csv`));
            // name is for fields like number etc. to allow to group multiple entries
            out.write(`kind,name,${(0, summarizer_1.summarizedMeasurement2CsvHeader)()}\n`);
            for (const [name, vals] of Object.entries(data)) {
                if (Array.isArray(vals)) {
                    out.write(`${JSON.stringify(name)},"",${(0, summarizer_1.summarizedMeasurement2Csv)((0, summarizer_1.summarizeMeasurement)(vals.flat()))}\n`);
                }
                else {
                    for (const [keyName, keyValue] of Object.entries(vals)) {
                        out.write(`${JSON.stringify(name)},${JSON.stringify(keyName)},${(0, summarizer_1.summarizedMeasurement2Csv)((0, summarizer_1.summarizeMeasurement)(keyValue.flat()))}\n`);
                    }
                }
            }
            out.close();
        }
    }
}
//# sourceMappingURL=post-process.js.map