"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.postProcess = postProcess;
const post_processing_1 = require("../../post-processing");
const common_syntax_probability_1 = require("../../common-syntax-probability");
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const numbers_1 = require("../../../../util/numbers");
const summarizer_1 = require("../../../../util/summarizer");
function postProcess(featureRoot, info, outputPath, config) {
    const collected = {
        forLoops: (0, common_syntax_probability_1.emptyCommonSyntaxTypeCounts)(() => []),
        forLoopVar: (0, common_syntax_probability_1.emptyCommonSyntaxTypeCounts)(() => []),
        forBody: (0, common_syntax_probability_1.emptyCommonSyntaxTypeCounts)(() => []),
        whileLoops: (0, common_syntax_probability_1.emptyCommonSyntaxTypeCounts)(() => []),
        whileBody: (0, common_syntax_probability_1.emptyCommonSyntaxTypeCounts)(() => []),
        repeatLoops: (0, post_processing_1.emptySummarizedWithProject)(),
        repeatBody: (0, common_syntax_probability_1.emptyCommonSyntaxTypeCounts)(() => []),
        breakStatements: (0, post_processing_1.emptySummarizedWithProject)(),
        nextStatements: (0, post_processing_1.emptySummarizedWithProject)(),
        implicitLoops: (0, post_processing_1.emptySummarizedWithProject)(),
        nestedExplicitLoops: (0, post_processing_1.emptySummarizedWithProject)(),
        deepestExplicitNesting: (0, post_processing_1.emptySummarizedWithProject)()
    };
    for (const [filepath, data] of info.entries()) {
        const value = data.loops;
        for (const [key, val] of Object.entries(value)) {
            if (typeof val !== 'object') {
                const get = collected[key];
                get.count.push(typeof val === 'number' ? Number(val) : (0, numbers_1.bigint2number)(val));
                if (val > 0) {
                    (0, post_processing_1.recordFilePath)(get, filepath, config);
                }
            }
            else {
                (0, common_syntax_probability_1.appendCommonSyntaxTypeCounter)(collected[key], val);
            }
        }
    }
    const metaOut = fs_1.default.createWriteStream(path_1.default.join(outputPath, 'loops-meta.csv'));
    metaOut.write(`kind,unique-projects,unique-files,${(0, summarizer_1.summarizedMeasurement2CsvHeader)()}\n`);
    for (const [key, val] of Object.entries(collected)) {
        const data = val;
        if ('uniqueProjects' in data) {
            metaOut.write(`${JSON.stringify(key)},${data.uniqueProjects.size},${data.uniqueFiles.size},${(0, summarizer_1.summarizedMeasurement2Csv)((0, summarizer_1.summarizeMeasurement)(data.count))}\n`);
        }
        else {
            // new file for each :D
            const out = fs_1.default.createWriteStream(path_1.default.join(outputPath, `loops-type-${key}.csv`));
            // name is for fields like number etc to allow to group multiple entries
            out.write(`kind,name,${(0, summarizer_1.summarizedMeasurement2CsvHeader)()}\n`);
            for (const [name, vals] of Object.entries(data)) {
                if (Array.isArray(vals)) {
                    out.write(`${JSON.stringify(name)},"",${(0, summarizer_1.summarizedMeasurement2Csv)((0, summarizer_1.summarizeMeasurement)(vals.flat()))}\n`);
                }
                else {
                    for (const [keyName, keyValue] of Object.entries(vals)) {
                        out.write(`${JSON.stringify(name)},${JSON.stringify(keyName)},${(0, summarizer_1.summarizedMeasurement2Csv)((0, summarizer_1.summarizeMeasurement)(keyValue.flat()))}\n`);
                    }
                }
            }
            out.close();
        }
    }
    metaOut.close();
}
//# sourceMappingURL=post-process.js.map