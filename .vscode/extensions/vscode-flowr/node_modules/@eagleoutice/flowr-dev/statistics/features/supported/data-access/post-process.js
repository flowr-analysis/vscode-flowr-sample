"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.postProcess = postProcess;
const common_syntax_probability_1 = require("../../common-syntax-probability");
const post_processing_1 = require("../../post-processing");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const numbers_1 = require("../../../../util/numbers");
const summarizer_1 = require("../../../../util/summarizer");
function addToList(data, dataAccess, filepath, config) {
    data.count.push(dataAccess);
    if (dataAccess > 0) {
        (0, post_processing_1.recordFilePath)(data, filepath, config);
    }
}
function summarizeForBracket(dataAccess, data, filepath, config) {
    for (const [key, val] of Object.entries(dataAccess)) {
        const numericKey = Number(key);
        const get = data.get(numericKey) ?? (0, common_syntax_probability_1.emptyCommonSyntaxTypeCounts)(() => []);
        if (typeof val === 'bigint' || typeof val === 'string') {
            // it is for argument 0
            const sumGet = get;
            const numericVal = (0, numbers_1.bigint2number)(val);
            sumGet.count.push(numericVal);
            if (numericVal > 0) {
                (0, post_processing_1.recordFilePath)(sumGet, filepath, config);
            }
        }
        else {
            (0, common_syntax_probability_1.appendCommonSyntaxTypeCounter)(get, val);
        }
        data.set(numericKey, get);
    }
}
function writeSingleOrDoubleEmpty(outputPath, key, name, vals) {
    const out = fs_1.default.createWriteStream(path_1.default.join(outputPath, `data-access-type-${key}-${name}.csv`));
    // name is for fields like number etc. to allow to group multiple entries
    out.write(`kind,unique-projects,unique-files,${(0, summarizer_1.summarizedMeasurement2CsvHeader)()}\n`);
    out.write(`"0",${vals.uniqueProjects.size},${vals.uniqueFiles.size},${(0, summarizer_1.summarizedMeasurement2Csv)((0, summarizer_1.summarizeMeasurement)(vals.count))}\n`);
    out.close();
}
function writeSingleOrDoubleBrackets(data, outputPath, key) {
    for (const [name, vals] of data.entries()) {
        // the 0 column
        if ('uniqueProjects' in vals) {
            writeSingleOrDoubleEmpty(outputPath, key, name, vals);
        }
        else {
            // non-0-column
            const out = fs_1.default.createWriteStream(path_1.default.join(outputPath, `data-access-type-${key}-${name}.csv`));
            // name is for fields like number etc. to allow to group multiple entries
            out.write(`kind,name,${(0, summarizer_1.summarizedMeasurement2CsvHeader)()}\n`);
            for (const [entryName, values] of Object.entries(vals)) {
                if (Array.isArray(values)) {
                    out.write(`${JSON.stringify(entryName)},"",${(0, summarizer_1.summarizedMeasurement2Csv)((0, summarizer_1.summarizeMeasurement)(values.flat()))}\n`);
                }
                else {
                    for (const [keyName, keyValue] of Object.entries(values)) {
                        out.write(`${JSON.stringify(entryName)},${JSON.stringify(keyName)},${(0, summarizer_1.summarizedMeasurement2Csv)((0, summarizer_1.summarizeMeasurement)(keyValue.flat()))}\n`);
                    }
                }
            }
            out.close();
        }
    }
}
function postProcess(featureRoot, info, outputPath, config) {
    const summarize = {
        singleBracket: new Map(),
        doubleBracket: new Map(),
        chainedOrNestedAccess: (0, post_processing_1.emptySummarizedWithProject)(),
        longestChain: (0, post_processing_1.emptySummarizedWithProject)(),
        deepestNesting: (0, post_processing_1.emptySummarizedWithProject)(),
        byName: (0, post_processing_1.emptySummarizedWithProject)(),
        bySlot: (0, post_processing_1.emptySummarizedWithProject)()
    };
    // initialize the special 0
    summarize.singleBracket.set(0, (0, post_processing_1.emptySummarizedWithProject)());
    summarize.doubleBracket.set(0, (0, post_processing_1.emptySummarizedWithProject)());
    for (const [filepath, value] of info.entries()) {
        const dataAccess = value.dataAccess;
        addToList(summarize.chainedOrNestedAccess, dataAccess.chainedOrNestedAccess, filepath, config);
        addToList(summarize.longestChain, dataAccess.longestChain, filepath, config);
        addToList(summarize.deepestNesting, dataAccess.deepestNesting, filepath, config);
        addToList(summarize.byName, dataAccess.byName, filepath, config);
        addToList(summarize.bySlot, dataAccess.bySlot, filepath, config);
        summarizeForBracket(dataAccess.singleBracket, summarize.singleBracket, filepath, config);
        summarizeForBracket(dataAccess.doubleBracket, summarize.doubleBracket, filepath, config);
    }
    const metaOut = fs_1.default.createWriteStream(path_1.default.join(outputPath, 'data-access-meta.csv'));
    metaOut.write(`kind,unique-projects,unique-files,${(0, summarizer_1.summarizedMeasurement2CsvHeader)()}\n`);
    for (const [key, value] of Object.entries(summarize)) {
        const data = value;
        if ('uniqueProjects' in data) {
            metaOut.write(`${JSON.stringify(key)},${data.uniqueProjects.size},${data.uniqueFiles.size},${(0, summarizer_1.summarizedMeasurement2Csv)((0, summarizer_1.summarizeMeasurement)(data.count))}\n`);
            continue;
        }
        writeSingleOrDoubleBrackets(data, outputPath, key);
    }
    metaOut.close();
}
//# sourceMappingURL=post-process.js.map