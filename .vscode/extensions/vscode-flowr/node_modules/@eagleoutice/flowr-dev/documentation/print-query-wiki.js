"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const shell_1 = require("../r-bridge/shell");
const doc_dfg_1 = require("./doc-util/doc-dfg");
const log_1 = require("../../test/functionality/_helper/log");
const query_1 = require("../queries/query");
const doc_files_1 = require("./doc-util/doc-files");
const doc_query_1 = require("./doc-util/doc-query");
const call_context_query_format_1 = require("../queries/call-context-query/call-context-query-format");
const schema_1 = require("../util/schema");
const query_schema_1 = require("../queries/query-schema");
const ansi_1 = require("../util/ansi");
const call_context_query_executor_1 = require("../queries/call-context-query/call-context-query-executor");
const compound_query_1 = require("../queries/virtual-query/compound-query");
const doc_auto_gen_1 = require("./doc-util/doc-auto-gen");
const fileCode = `
library(ggplot)
library(dplyr)
library(readr)

# read data with read_csv
data <- read_csv('data.csv')
data2 <- read_csv('data2.csv')

m <- mean(data$x) 
print(m)

data %>%
	ggplot(aes(x = x, y = y)) +
	geom_point()
	
plot(data2$x, data2$y)
points(data2$x, data2$y)
	
print(mean(data2$k))
`.trim();
(0, doc_query_1.registerQueryDocumentation)('call-context', {
    name: 'Call-Context Query',
    type: 'active',
    shortDescription: 'Finds all calls in a set of files that matches specified criteria.',
    functionName: call_context_query_executor_1.executeCallContextQueries.name,
    functionFile: '../queries/call-context-query/call-context-query-executor.ts',
    buildExplanation: async (shell) => {
        return `
Call context queries may be used to identify calls to specific functions that match criteria of your interest.
For now, we support two criteria:

1. **Function Name** (\`callName\`): The function name is specified by a regular expression. This allows you to find all calls to functions that match a specific pattern.
2. **Call Targets**  (\`callTargets\`): This specifies to what the function call targets. For example, you may want to find all calls to a function that is not defined locally.

Besides this we provide three ways to automatically categorize and link identified invocations:

1. **Kind**         (\`kind\`): This is a general category that can be used to group calls together. For example, you may want to link all calls to \`plot\` to \`visualize\`.
2. **Subkind**      (\`subkind\`): This is used to uniquely identify the respective call type when grouping the output. For example, you may want to link all calls to \`ggplot\` to \`plot\`.
3. **Linked Calls** (\`linkTo\`): This links the current call to the last call of the given kind. This way, you can link a call like \`points\` to the latest graphics plot etc.
   For now, we _only_offer support for linking to the last call_ as the current flow dependency over-approximation is not stable.

Re-using the example code from above, the following query attaches all calls to \`mean\` to the kind \`visualize\` and the subkind \`text\`,
all calls that start with \`read_\` to the kind \`input\` but only if they are not locally overwritten, and the subkind \`csv-file\`, and links all calls to \`points\` to the last call to \`plot\`:

${await (0, doc_query_1.showQuery)(shell, fileCode, [
            { type: 'call-context', callName: '^mean$', kind: 'visualize', subkind: 'text' },
            { type: 'call-context', callName: '^read_', kind: 'input', subkind: 'csv-file', callTargets: call_context_query_format_1.CallTargets.OnlyGlobal },
            { type: 'call-context', callName: '^points$', kind: 'visualize', subkind: 'plot', linkTo: { type: 'link-to-last-call', callName: '^plot$' } }
        ], { showCode: false })}

As you can see, all kinds and subkinds with the same name are grouped together.
Yet, re-stating common arguments and kinds may be cumbersome (although you can already use clever regex patterns).
See the [Compound Query](#compound-query) for a way to structure your queries more compactly if you think it gets too verbose. 

		`;
    }
});
(0, doc_query_1.registerQueryDocumentation)('compound', {
    name: 'Compound Query',
    type: 'virtual',
    shortDescription: 'Combines multiple queries of the same type into one, specifying common arguments.',
    functionName: compound_query_1.executeCompoundQueries.name,
    functionFile: '../queries/virtual-query/compound-query.ts',
    buildExplanation: async (shell) => {
        return `
A compound query comes in use, whenever we want to state multiple queries of the same type with a set of common arguments.
It offers the following properties of interest:

1. **Query** (\`query\`): the type of the query that is to be combined.
2. **Common Arguments** (\`commonArguments\`): The arguments that are to be used as defaults for all queries (i.e., any argument the query may have).
3. **Arguments** (\`arguments\`): The other arguments for the individual queries that are to be combined.

For example, consider the following compound query that combines two call-context queries for \`mean\` and \`print\`, both of which are to be
assigned to the kind \`visualize\` and the subkind \`text\` (using the example code from above):

${await (0, doc_query_1.showQuery)(shell, fileCode, [{
                type: 'compound',
                query: 'call-context',
                commonArguments: { kind: 'visualize', subkind: 'text' },
                arguments: [
                    { callName: '^mean$' },
                    { callName: '^print$' }
                ]
            }], { showCode: false })}

Of course, in this specific scenario, the following query would be equivalent:

${await (0, doc_query_1.showQuery)(shell, fileCode, [
            { type: 'call-context', callName: '^(mean|print)$', kind: 'visualize', subkind: 'text' }
        ], { showCode: false, collapseResult: true })}

However, compound queries become more useful whenever common arguments can not be expressed as a union in one of their properties.
Additionally, you can still overwrite default arguments. 
In the following, we (by default) want all calls to not resolve to a local definition, except for those to \`print\` for which we explicitly
want to resolve to a local definition:

${await (0, doc_query_1.showQuery)(shell, fileCode, [{
                type: 'compound',
                query: 'call-context',
                commonArguments: { kind: 'visualize', subkind: 'text', callTargets: call_context_query_format_1.CallTargets.OnlyGlobal },
                arguments: [
                    { callName: '^mean$' },
                    { callName: '^print$', callTargets: call_context_query_format_1.CallTargets.OnlyLocal }
                ]
            }], { showCode: false })}

Now, the results no longer contain calls to \`plot\` that are not defined locally. 

		`;
    }
});
async function getText(shell) {
    const rversion = (await shell.usedRVersion())?.format() ?? 'unknown';
    return `${(0, doc_auto_gen_1.autoGenHeader)({ filename: module.filename, purpose: 'query API', rVersion: rversion })}

This page briefly summarizes flowR's query API, represented by the ${query_1.executeQueries.name} function in ${(0, doc_files_1.getFilePathMd)('../queries/query.ts')}.
Please see the [Interface](${doc_files_1.FlowrWikiBaseRef}/Interface) wiki page for more information on how to access this API.

First, consider that you have a file like the following (of course, this is just a simple and artificial example):

\`\`\`r
${fileCode}
\`\`\`

<details> <summary>Dataflow Graph of the Example</summary>

${await (0, doc_dfg_1.printDfGraphForCode)(shell, fileCode, { showCode: false })}

</details>

&nbsp;

Additionally, consider that you are interested in all function calls which loads data with \`read_csv\`.
A simple \`regex\`-based query could look like this: \`^read_csv$\`.
However, this fails to incorporate
 
1. Syntax-based information (comments, strings, used as a variable, called as a higher-order function, ...)
2. Semantic information (e.g., \`read_csv\` is overwritten by a function with the same name)
3. Context information (e.g., calls like \`points\` may link to the current plot)

To solve this, flowR provides a query API which allows you to specify queries on the dataflow graph.
For the specific use-case stated, you could use the [Call-Context Query](#call-context-query) to find all calls to \`read_csv\` which refer functions that are not overwritten.

Just as an example, the following [Call-Context Query](#call-context-query) finds all calls to \`read_csv\` that are not overwritten:

${await (0, doc_query_1.showQuery)(shell, fileCode, [{ type: 'call-context', callName: '^read_csv$', callTargets: call_context_query_format_1.CallTargets.OnlyGlobal, kind: 'input', subkind: 'csv-file' }], { showCode: false })}

## The Query Format

Queries are JSON arrays of query objects, each of which uses a \`type\` property to specify the query type.
In general, we separate two types of queries:

1. **Active Queries**: Are exactly what you would expect from a query (e.g., the [Call-Context Query](#call-context-query)). They fetch information from the dataflow graph.
2. **Virtual Queries**: Are used to structure your queries (e.g., the [Compound Query](#compound-query)). 

We separate these from a concept perspective. 
For now, we support the following **active** queries (which we will refer to simply as a \`query\`):

${(0, doc_query_1.tocForQueryType)('active')}

Similarly, we support the following **virtual** queries: 

${(0, doc_query_1.tocForQueryType)('virtual')}

<details>


<summary>Detailed Query Format (Automatically Generated)</summary>

Although it is probably better to consult the detailed explanations below, if you want to have a look at the scehma, here is its description:

${(0, schema_1.describeSchema)(query_schema_1.QueriesSchema, ansi_1.markdownFormatter)}

</details>

${await (0, doc_query_1.explainQueries)(shell, 'active')}

${await (0, doc_query_1.explainQueries)(shell, 'virtual')}

`;
}
/** if we run this script, we want a Markdown representation of the capabilities */
if (require.main === module) {
    (0, log_1.setMinLevelOfAllLogs)(6 /* LogLevel.Fatal */);
    const shell = new shell_1.RShell();
    void getText(shell).then(str => {
        console.log(str);
    }).finally(() => {
        shell.close();
    });
}
//# sourceMappingURL=print-query-wiki.js.map