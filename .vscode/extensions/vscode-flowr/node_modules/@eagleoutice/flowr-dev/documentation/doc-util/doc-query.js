"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegisteredQueries = void 0;
exports.showQuery = showQuery;
exports.registerQueryDocumentation = registerQueryDocumentation;
exports.tocForQueryType = tocForQueryType;
exports.explainQueries = explainQueries;
const query_1 = require("../../queries/query");
const pipeline_executor_1 = require("../../core/pipeline-executor");
const default_pipelines_1 = require("../../core/steps/pipeline/default-pipelines");
const retriever_1 = require("../../r-bridge/retriever");
const doc_ms_1 = require("./doc-ms");
const json_1 = require("../../util/json");
const ansi_1 = require("../../util/ansi");
const repl_query_1 = require("../../cli/repl/commands/repl-query");
const doc_files_1 = require("./doc-files");
async function showQuery(shell, code, queries, { showCode, collapseResult } = {}) {
    const now = performance.now();
    const analysis = await new pipeline_executor_1.PipelineExecutor(default_pipelines_1.DEFAULT_DATAFLOW_PIPELINE, {
        shell,
        request: (0, retriever_1.requestFromInput)(code)
    }).allRemainingSteps();
    const results = (0, query_1.executeQueries)({ graph: analysis.dataflow.graph, ast: analysis.normalize }, queries);
    const duration = performance.now() - now;
    const metaInfo = `
The analysis required _${(0, doc_ms_1.printAsMs)(duration)}_ (including parsing and normalization and the query) within the generation environment.
	`.trim();
    const resultAsString = JSON.stringify(results, json_1.jsonReplacer, 2);
    return `

\`\`\`json
${JSON.stringify(queries, json_1.jsonReplacer, 2)}
\`\`\`

${collapseResult ? ' <details> <summary style="color:gray">Show Results</summary>' : ''}

_Results (prettified and summarized):_

${(0, repl_query_1.asciiSummaryOfQueryResult)(ansi_1.markdownFormatter, duration, results, analysis)}

<details> <summary style="color:gray">Show Detailed Results as Json</summary>

${metaInfo}	

In general, the JSON contains the Ids of the nodes in question as they are present in the normalized AST or the dataflow graph of flowR.
Please consult the [Interface](${doc_files_1.FlowrWikiBaseRef}/Interface) wiki page for more information on how to get those.

\`\`\`json
${resultAsString}
\`\`\`

${showCode ? `
<details> <summary style="color:gray">Original Code</summary>

\`\`\`r
${code}
\`\`\`

</details>
	` : ''}

</details>

${collapseResult ? '</details>' : ''}

	`;
}
exports.RegisteredQueries = {
    'active': new Map(),
    'virtual': new Map()
};
function registerQueryDocumentation(query, doc) {
    const map = exports.RegisteredQueries[doc.type];
    if (map.has(query)) {
        throw new Error(`Query ${query} already registered`);
    }
    map.set(query, doc);
}
function linkify(name) {
    return name.toLowerCase().replace(/ /g, '-');
}
function tocForQueryType(type) {
    const queries = exports.RegisteredQueries[type];
    const result = [];
    for (const [id, { name, shortDescription }] of queries) {
        result.push(`1. [${name}](#${linkify(name)}) (\`${id}\`):\\\n    ${shortDescription}`);
    }
    return result.join('\n');
}
async function explainQuery(shell, { name, functionName, functionFile, buildExplanation }) {
    return `
### ${name}

${await buildExplanation(shell)}

<details> 

<summary style="color:gray">Implementation Details</summary>

Responsible for the execution of the ${name} query is \`${functionName}\` in ${(0, doc_files_1.getFilePathMd)(functionFile)}.

</details>	

`;
}
async function explainQueries(shell, type) {
    const queries = exports.RegisteredQueries[type];
    const result = [];
    for (const doc of queries.values()) {
        result.push(await explainQuery(shell, doc));
    }
    return result.join('\n\n\n');
}
//# sourceMappingURL=doc-query.js.map