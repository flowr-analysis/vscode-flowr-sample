"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printDfGraph = printDfGraph;
exports.printDfGraphForCode = printDfGraphForCode;
exports.verifyExpectedSubgraph = verifyExpectedSubgraph;
const dfg_1 = require("../../util/mermaid/dfg");
const pipeline_executor_1 = require("../../core/pipeline-executor");
const default_pipelines_1 = require("../../core/steps/pipeline/default-pipelines");
const retriever_1 = require("../../r-bridge/retriever");
const decorate_1 = require("../../r-bridge/lang-4.x/ast/model/processing/decorate");
const resolve_graph_1 = require("../../dataflow/graph/resolve-graph");
const diff_1 = require("../../dataflow/graph/diff");
const assert_1 = require("../../util/assert");
const doc_ms_1 = require("./doc-ms");
const json_1 = require("../../util/json");
function printDfGraph(graph, mark) {
    return `
\`\`\`mermaid
${(0, dfg_1.graphToMermaid)({
        graph,
        prefix: 'flowchart LR',
        mark
    }).string}
\`\`\`
	`;
}
async function printDfGraphForCode(shell, code, { mark, showCode = true } = {}) {
    const now = performance.now();
    const result = await new pipeline_executor_1.PipelineExecutor(default_pipelines_1.DEFAULT_DATAFLOW_PIPELINE, {
        shell,
        request: (0, retriever_1.requestFromInput)(code)
    }).allRemainingSteps();
    const duration = performance.now() - now;
    const metaInfo = `The analysis required _${(0, doc_ms_1.printAsMs)(duration)}_ (including parsing and normalization) within the generation environment.`;
    return '\n\n' + printDfGraph(result.dataflow.graph, mark) + (showCode ? `
<details>

<summary style="color:gray">R Code of the Dataflow Graph</summary>

${metaInfo} ${mark ? `The following marks are used in the graph to highlight sub-parts (uses ids): ${[...mark].join(', ')}.` : ''}
We encountered ${result.dataflow.graph.unknownSideEffects.size > 0 ? 'unknown side effects (with ids: ' + JSON.stringify(result.dataflow.graph.unknownSideEffects, json_1.jsonReplacer) + ')' : 'no unknown side effects'} during the analysis.

\`\`\`r
${code}
\`\`\`

<details>

<summary style="color:gray">Mermaid Code ${(mark?.size ?? 0) > 0 ? '(without markings)' : ''}</summary>

\`\`\`
${(0, dfg_1.graphToMermaid)({
        graph: result.dataflow.graph,
        prefix: 'flowchart LR'
    }).string}
\`\`\`

</details>

</details>

` : '\n(' + metaInfo + ')\n\n');
}
/** returns resolved expected df graph */
async function verifyExpectedSubgraph(shell, code, expectedSubgraph) {
    /* we verify that we get what we want first! */
    const info = await new pipeline_executor_1.PipelineExecutor(default_pipelines_1.DEFAULT_DATAFLOW_PIPELINE, {
        shell,
        request: (0, retriever_1.requestFromInput)(code),
        getId: (0, decorate_1.deterministicCountingIdGenerator)(0)
    }).allRemainingSteps();
    expectedSubgraph.setIdMap(info.normalize.idMap);
    expectedSubgraph = (0, resolve_graph_1.resolveDataflowGraph)(expectedSubgraph);
    const report = (0, diff_1.diffOfDataflowGraphs)({ name: 'expected', graph: expectedSubgraph }, { name: 'got', graph: info.dataflow.graph }, {
        leftIsSubgraph: true
    });
    (0, assert_1.guard)(report.isEqual(), () => `report:\n * ${report.comments()?.join('\n * ') ?? ''}`);
    return expectedSubgraph;
}
//# sourceMappingURL=doc-dfg.js.map