"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseToQuads = parseToQuads;
const quads_1 = require("../../util/quads");
const parser_1 = require("../../r-bridge/lang-4.x/ast/parser/json/parser");
const format_1 = require("../../r-bridge/lang-4.x/ast/parser/json/format");
const input_format_1 = require("../../r-bridge/lang-4.x/ast/parser/xml/input-format");
function filterObject(obj, keys) {
    if (typeof obj !== 'object') {
        return obj;
    }
    else if (Array.isArray(obj)) {
        return obj.map(e => filterObject(e, keys));
    }
    if (Object.keys(obj).some(k => keys.has(k))) {
        return Object.fromEntries(Object.entries(obj)
            .filter(([k]) => keys.has(k))
            .map(([k, v]) => [k, filterObject(v, keys)]));
    }
    else {
        return Object.fromEntries(Object.entries(obj)
            .map(([k, v]) => [k, filterObject(v, keys)]));
    }
}
function parseToQuads(code, config) {
    const obj = (0, parser_1.convertPreparedParsedData)((0, format_1.prepareParsedData)(code));
    // recursively filter so that if the object contains one of the keys 'a', 'b' or 'c', all other keys are ignored
    return (0, quads_1.serialize2quads)(filterObject(obj, new Set([input_format_1.attributesKey, input_format_1.childrenKey, input_format_1.contentKey])), config);
}
//# sourceMappingURL=parse-printer.js.map