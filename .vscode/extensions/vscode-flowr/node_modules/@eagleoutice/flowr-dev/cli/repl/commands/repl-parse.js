"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseCommand = void 0;
const pipeline_executor_1 = require("../../../core/pipeline-executor");
const format_1 = require("../../../r-bridge/lang-4.x/ast/parser/json/format");
const parser_1 = require("../../../r-bridge/lang-4.x/ast/parser/json/parser");
const input_format_1 = require("../../../r-bridge/lang-4.x/ast/parser/xml/input-format");
const normalize_meta_1 = require("../../../r-bridge/lang-4.x/ast/parser/xml/normalize-meta");
const default_pipelines_1 = require("../../../core/steps/pipeline/default-pipelines");
const retriever_1 = require("../../../r-bridge/retriever");
function toDepthMap(xml) {
    const root = (0, input_format_1.getKeyGuarded)(xml, "exprlist" /* RawRType.ExpressionList */);
    const visit = [{ depth: 0, node: root }];
    const result = [];
    while (visit.length > 0) {
        const current = visit.pop();
        if (current === undefined) {
            continue;
        }
        const children = current.node[input_format_1.childrenKey] ?? [];
        result.push({ ...current, leaf: children.length === 0 });
        children.reverse();
        const nextDepth = current.depth + 1;
        visit.push(...children.map(c => ({ depth: nextDepth, node: c })));
    }
    return result;
}
function lastElementInNesting(i, list, depth) {
    for (let j = i + 1; j < list.length; j++) {
        if (list[j].depth < depth) {
            return true;
        }
        if (list[j].depth === depth) {
            return false;
        }
    }
    // only more deeply nested come after
    return true;
}
function initialIndentation(i, depth, deadDepths, nextDepth, list, f) {
    let result = `${i === 0 ? '' : '\n'}${f.getFormatString({ style: 2 /* FontStyles.Faint */ })}`;
    // we know there never is something on the same level as the expression list
    for (let d = 1; d < depth; d++) {
        result += deadDepths.has(d) ? '  ' : '│ ';
    }
    if (nextDepth < depth) {
        result += '╰ ';
    }
    else if (i > 0) {
        // check if we are maybe the last one with this depth until someone with a lower depth comes around
        const isLast = lastElementInNesting(i, list, depth);
        result += isLast ? '╰ ' : '├ ';
        if (isLast) {
            deadDepths.add(depth);
        }
    }
    return result;
}
function retrieveLocationString(locationRaw) {
    const extracted = (0, normalize_meta_1.extractLocation)(locationRaw);
    if (extracted[0] === extracted[2] && extracted[1] === extracted[3]) {
        return ` (${extracted[0]}:${extracted[1]})`;
    }
    else {
        return ` (${extracted[0]}:${extracted[1]}─${extracted[2]}:${extracted[3]})`;
    }
}
function depthListToTextTree(list, f) {
    let result = '';
    const deadDepths = new Set();
    let i = 0;
    for (const { depth, node, leaf } of list) {
        const nextDepth = i + 1 < list.length ? list[i + 1].depth : 0;
        deadDepths.delete(depth);
        result += initialIndentation(i, depth, deadDepths, nextDepth, list, f);
        result += f.reset();
        const raw = (0, normalize_meta_1.objectWithArrUnwrap)(node);
        const content = raw[input_format_1.contentKey];
        const locationRaw = raw[input_format_1.attributesKey];
        let location = '';
        if (locationRaw !== undefined) {
            location = retrieveLocationString(locationRaw);
        }
        const type = (0, normalize_meta_1.getTokenType)(node);
        if (leaf) {
            const suffix = `${f.format(content ? JSON.stringify(content) : '', { style: 1 /* FontStyles.Bold */ })}${f.format(location, { style: 3 /* FontStyles.Italic */ })}`;
            result += `${type} ${suffix}`;
        }
        else {
            result += f.format(type, { style: 1 /* FontStyles.Bold */ });
        }
        i++;
    }
    return result;
}
exports.parseCommand = {
    description: `Prints ASCII Art of the parsed, unmodified AST, start with '${retriever_1.fileProtocol}' to indicate a file`,
    usageExample: ':parse',
    aliases: ['p'],
    script: false,
    fn: async (output, shell, remainingLine) => {
        const result = await new pipeline_executor_1.PipelineExecutor(default_pipelines_1.DEFAULT_PARSE_PIPELINE, {
            shell,
            request: (0, retriever_1.requestFromInput)((0, retriever_1.removeRQuotes)(remainingLine.trim()))
        }).allRemainingSteps();
        const object = (0, parser_1.convertPreparedParsedData)((0, format_1.prepareParsedData)(result.parse));
        output.stdout(depthListToTextTree(toDepthMap(object), output.formatter));
    }
};
//# sourceMappingURL=repl-parse.js.map