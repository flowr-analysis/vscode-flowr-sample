"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_REPL_READLINE_CONFIGURATION = void 0;
exports.replCompleter = replCompleter;
exports.replProcessAnswer = replProcessAnswer;
exports.repl = repl;
exports.loadReplHistory = loadReplHistory;
/**
 * Basically a helper file to allow the main 'flowr' script (located in the source root) to provide its repl
 *
 * @module
 */
const prompt_1 = require("./prompt");
const readline = __importStar(require("readline"));
const repl_execute_1 = require("./commands/repl-execute");
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const args_1 = require("../../util/args");
const ansi_1 = require("../../util/ansi");
const repl_commands_1 = require("./commands/repl-commands");
const scripts_info_1 = require("../common/scripts-info");
const retriever_1 = require("../../r-bridge/retriever");
const repl_main_1 = require("./commands/repl-main");
const shell_1 = require("../../r-bridge/shell");
let _replCompleterKeywords = undefined;
function replCompleterKeywords() {
    if (_replCompleterKeywords === undefined) {
        _replCompleterKeywords = Array.from((0, repl_commands_1.getCommandNames)(), s => `:${s}`);
    }
    return _replCompleterKeywords;
}
const defaultHistoryFile = path_1.default.join(os_1.default.tmpdir(), '.flowrhistory');
/**
 * Used by the repl to provide automatic completions for a given (partial) input line
 */
function replCompleter(line) {
    const splitLine = (0, args_1.splitAtEscapeSensitive)(line);
    // did we just type a space (and are starting a new arg right now)?
    const startingNewArg = line.endsWith(' ');
    // if we typed a command fully already, autocomplete the arguments
    if (splitLine.length > 1 || startingNewArg) {
        const commandNameColon = replCompleterKeywords().find(k => splitLine[0] === k);
        if (commandNameColon) {
            const completions = [];
            const commandName = commandNameColon.slice(1);
            if ((0, repl_commands_1.getCommand)(commandName)?.script === true) {
                // autocomplete script arguments
                const options = scripts_info_1.scripts[commandName].options;
                completions.push(...(0, scripts_info_1.getValidOptionsForCompletion)(options, splitLine).map(o => `${o} `));
            }
            else {
                // autocomplete command arguments (specifically, autocomplete the file:// protocol)
                completions.push(retriever_1.fileProtocol);
            }
            // add an empty option so that it doesn't autocomplete the only defined option immediately
            completions.push(' ');
            const currentArg = startingNewArg ? '' : splitLine[splitLine.length - 1];
            return [completions.filter(a => a.startsWith(currentArg)), currentArg];
        }
    }
    // if no command is already typed, just return all commands that match
    return [replCompleterKeywords().filter(k => k.startsWith(line)).map(k => `${k} `), line];
}
exports.DEFAULT_REPL_READLINE_CONFIGURATION = {
    input: process.stdin,
    output: process.stdout,
    tabSize: 4,
    terminal: true,
    history: loadReplHistory(defaultHistoryFile),
    removeHistoryDuplicates: true,
    completer: replCompleter
};
async function replProcessStatement(output, statement, shell, allowRSessionAccess) {
    if (statement.startsWith(':')) {
        const command = statement.slice(1).split(' ')[0].toLowerCase();
        const processor = (0, repl_commands_1.getCommand)(command);
        const bold = (s) => output.formatter.format(s, { style: 1 /* FontStyles.Bold */ });
        if (processor) {
            try {
                await processor.fn(output, shell, statement.slice(command.length + 2).trim());
            }
            catch (e) {
                output.stdout(`${bold(`Failed to execute command ${command}`)}: ${e?.message}. Using the ${bold('--verbose')} flag on startup may provide additional information.\n`);
            }
        }
        else {
            output.stdout(`the command '${command}' is unknown, try ${bold(':help')} for more information\n`);
        }
    }
    else if (allowRSessionAccess) {
        await (0, repl_execute_1.executeRShellCommand)(output, shell, statement);
    }
    else {
        output.stderr(`${output.formatter.format('You are not allowed to execute arbitrary R code.', { style: 1 /* FontStyles.Bold */, color: 1 /* Colors.Red */, effect: ansi_1.ColorEffect.Foreground })}\nIf you want to do so, please restart flowR with the ${output.formatter.format('--r-session-access', { style: 1 /* FontStyles.Bold */ })} flag. Please be careful of the security implications of this action.`);
    }
}
/**
 * This function interprets the given `expr` as a REPL command (see {@link repl} for more on the semantics).
 *
 * @param output              - Defines two methods that every function in the repl uses to output its data.
 * @param expr                - The expression to process.
 * @param shell               - The {@link RShell} to use (see {@link repl}).
 * @param allowRSessionAccess - If true, allows the execution of arbitrary R code.
 */
async function replProcessAnswer(output, expr, shell, allowRSessionAccess) {
    const statements = (0, args_1.splitAtEscapeSensitive)(expr, false, ';');
    for (const statement of statements) {
        await replProcessStatement(output, statement, shell, allowRSessionAccess);
    }
}
/**
 * Provides a never-ending repl (read-evaluate-print loop) processor that can be used to interact with a {@link RShell} as well as all flowR scripts.
 *
 * The repl allows for two kinds of inputs:
 * - Starting with a colon `:`, indicating a command (probe `:help`, and refer to {@link commands}) </li>
 * - Starting with anything else, indicating default R code to be directly executed. If you kill the underlying shell, that is on you! </li>
 *
 * @param options - The options for the repl. See {@link FlowrReplOptions} for more information.
 *
 * For the execution, this function makes use of {@link replProcessAnswer}.
 *
 */
async function repl({ shell = new shell_1.RShell({ revive: 2 /* RShellReviveOptions.Always */ }), rl = readline.createInterface(exports.DEFAULT_REPL_READLINE_CONFIGURATION), output = repl_main_1.standardReplOutput, historyFile = defaultHistoryFile, allowRSessionAccess = false }) {
    if (historyFile) {
        rl.on('history', h => fs_1.default.writeFileSync(historyFile, h.join('\n'), { encoding: 'utf-8' }));
    }
    // the incredible repl :D, we kill it with ':quit'
    // eslint-disable-next-line no-constant-condition,@typescript-eslint/no-unnecessary-condition
    while (true) {
        await new Promise((resolve, reject) => {
            rl.question((0, prompt_1.prompt)(), answer => {
                rl.pause();
                replProcessAnswer(output, answer, shell, allowRSessionAccess).then(() => {
                    rl.resume();
                    resolve();
                }).catch(reject);
            });
        });
    }
}
function loadReplHistory(historyFile) {
    if (!fs_1.default.existsSync(historyFile)) {
        return undefined;
    }
    return fs_1.default.readFileSync(historyFile, { encoding: 'utf-8' }).split('\n');
}
//# sourceMappingURL=core.js.map