"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatter = exports.ansiFormatter = exports.escape = exports.markdownFormatter = exports.voidFormatter = exports.ColorEffect = void 0;
exports.italic = italic;
exports.bold = bold;
exports.setFormatter = setFormatter;
// noinspection JSUnusedGlobalSymbols
var ColorEffect;
(function (ColorEffect) {
    ColorEffect[ColorEffect["Foreground"] = 30] = "Foreground";
    ColorEffect[ColorEffect["Background"] = 40] = "Background";
})(ColorEffect || (exports.ColorEffect = ColorEffect = {}));
exports.voidFormatter = new class {
    format(input) {
        return input;
    }
    getFormatString(_options) {
        return '';
    }
    reset() {
        return '';
    }
}();
exports.markdownFormatter = new class {
    format(input, options) {
        if (options && 'style' in options) {
            if (options.style === 1 /* FontStyles.Bold */) {
                input = `**${input}**`;
            }
            else if (options.style === 3 /* FontStyles.Italic */) {
                input = `_${input}_`;
            }
            else {
                throw new Error(`Unsupported font style: ${options.style}`);
            }
        }
        input = input.replaceAll(/\\/g, '\\\\');
        return input.replaceAll(/\n/g, '\\\n').replaceAll(/ /g, '&nbsp;');
    }
    getFormatString(_options) {
        return '';
    }
    reset() {
        return '';
    }
}();
/**
 * This does not work if the {@link setFormatter|formatter} is void. Tries to format the text with a bold font weight.
 */
function italic(s, f = exports.formatter, options) {
    return f.format(s, { style: 3 /* FontStyles.Italic */, ...options });
}
/**
 * This does not work if the {@link setFormatter|formatter} is void. Tries to format the text with an italic font shape.
 */
function bold(s, f = exports.formatter, options) {
    return f.format(s, { style: 1 /* FontStyles.Bold */, ...options });
}
exports.escape = '\x1b[';
const colorSuffix = 'm';
exports.ansiFormatter = {
    reset() {
        return `${exports.escape}0${colorSuffix}`;
    },
    format(input, options) {
        return `${this.getFormatString(options)}${input}${this.reset()}`;
    },
    getFormatString(options) {
        if (options === undefined) {
            return '';
        }
        const colorString = 'color' in options ? `${options.effect + options.color}` : '';
        const weightString = 'style' in options ? `${options.style}` : '';
        return `${exports.escape}${colorString}${weightString !== '' ? ';' : ''}${weightString}${colorSuffix}`;
    }
};
exports.formatter = exports.ansiFormatter;
function setFormatter(setFormatter) {
    exports.formatter = setFormatter;
}
//# sourceMappingURL=ansi.js.map