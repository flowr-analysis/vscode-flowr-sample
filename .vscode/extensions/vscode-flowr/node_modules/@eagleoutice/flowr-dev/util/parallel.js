"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LimitedThreadPool = void 0;
/**
 * Tasked with parallelize the benchmarking by calling the given script in an executor-pool style fashion.
 * Now used to parallelize more in _flowR_.
 * @module parallel
 */
const cp = __importStar(require("child_process"));
const log_1 = require("./log");
const assert_1 = require("./assert");
const json_1 = require("./json");
/**
 * This is not really generic but written especially for the benchmarking script.
 * It offers a work stealing thread pool executor.
 */
class LimitedThreadPool {
    workingQueue;
    limit;
    parallel;
    module;
    counter = 0;
    skipped = [];
    currentlyRunning = new Set();
    reportingInterval = undefined;
    /**
   * Create a new parallel helper that runs the given `module` once for each list of {@link Arguments} in the `queue`.
   * The `limit` stops the execution if `<limit>` number of runs exited successfully.
   * The `parallel` parameter limits the number of parallel executions.
   */
    constructor(module, queue, limit, parallel) {
        this.workingQueue = queue;
        this.limit = limit;
        this.module = module;
        this.parallel = parallel;
    }
    async run() {
        this.reportingInterval = setInterval(() => {
            console.log(`Waiting for: ${JSON.stringify(this.currentlyRunning, json_1.jsonReplacer)}`);
        }, 20000);
        const promises = [];
        // initial run, runNext will schedule itself recursively we use the limit too if there are more cores than limit :D
        while (this.currentlyRunning.size < Math.min(this.parallel, this.limit) && this.workingQueue.length > 0) {
            promises.push(this.runNext());
        }
        await Promise.all(promises);
        clearInterval(this.reportingInterval);
    }
    getStats() {
        return { counter: this.counter, skipped: this.skipped };
    }
    async runNext() {
        if (this.counter + this.currentlyRunning.size >= this.limit || this.workingQueue.length <= 0) {
            console.log(`Skip running next as counter: ${this.counter} and currently running: ${this.currentlyRunning.size} beat ${this.limit} or ${this.workingQueue.length}`);
            return;
        }
        const args = this.workingQueue.pop();
        (0, assert_1.guard)(args !== undefined, () => `arguments should not be undefined in ${JSON.stringify(this.workingQueue)}`);
        this.currentlyRunning.add(args);
        console.log(`[${this.counter}/${this.limit}] Running next, currently running: ${this.currentlyRunning.size}, queue: ${this.workingQueue.length} [args: ${args.join(' ')}]`);
        const child = cp.fork(this.module, args);
        child.on('exit', this.onChildExit(args));
        // schedule re-schedule
        await new Promise(resolve => child.on('exit', resolve)).then(() => this.runNext());
    }
    onChildExit(args) {
        return (code, signal) => {
            if (code === 0) {
                this.counter++;
            }
            else {
                log_1.log.error(`Benchmark for ${JSON.stringify(args)} exited with code ${JSON.stringify(code)} (signal: ${JSON.stringify(signal)})`);
                this.skipped.push(args);
            }
            this.currentlyRunning.delete(args);
        };
    }
}
exports.LimitedThreadPool = LimitedThreadPool;
//# sourceMappingURL=parallel.js.map