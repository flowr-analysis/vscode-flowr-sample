"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BiMap = void 0;
/**
 * Implementation of a bidirectional map
 *
 * All map-related functions are based on the normal Key -&gt; Value map
 */
class BiMap {
    [Symbol.toStringTag] = 'BiMap';
    size = 0;
    k2v = new Map();
    v2k = new WeakMap();
    constructor(base) {
        if (base != null) {
            for (const [k, v] of base) {
                this.set(k, v);
            }
        }
    }
    [Symbol.iterator]() {
        return this.k2v[Symbol.iterator]();
    }
    clear() {
        this.size = 0;
        this.k2v.clear();
        this.v2k = new WeakMap();
    }
    delete(key) {
        const value = this.k2v.get(key);
        if (value === undefined) {
            return false;
        }
        this.k2v.delete(key);
        this.v2k.delete(value);
        this.size = this.k2v.size;
        return true;
    }
    entries() {
        return this.k2v.entries();
    }
    forEach(callbackFunction) {
        this.k2v.forEach(callbackFunction);
    }
    get(key) {
        return this.k2v.get(key);
    }
    getKey(value) {
        return this.v2k.get(value);
    }
    has(key) {
        return this.k2v.has(key);
    }
    hasValue(value) {
        return this.v2k.has(value);
    }
    keys() {
        return this.k2v.keys();
    }
    set(key, value) {
        this.k2v.set(key, value);
        this.v2k.set(value, key);
        this.size = this.k2v.size;
        return this;
    }
    values() {
        return this.k2v.values();
    }
}
exports.BiMap = BiMap;
//# sourceMappingURL=bimap.js.map