"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeCallContextQueries = executeCallContextQueries;
const call_context_query_format_1 = require("./call-context-query-format");
const vertex_1 = require("../../dataflow/graph/vertex");
const assert_1 = require("../../util/assert");
const edge_1 = require("../../dataflow/graph/edge");
const resolve_by_name_1 = require("../../dataflow/environments/resolve-by-name");
const built_in_1 = require("../../dataflow/environments/built-in");
const cfg_1 = require("../../util/cfg/cfg");
const two_layer_collector_1 = require("../two-layer-collector");
const objects_1 = require("../../util/objects");
const visitor_1 = require("../../util/cfg/visitor");
function satisfiesCallTargets(id, graph, callTarget) {
    const callVertex = graph.get(id);
    if (callVertex === undefined || callVertex[0].tag !== vertex_1.VertexType.FunctionCall) {
        return 'no';
    }
    const [info, outgoing] = callVertex;
    const callTargets = [...outgoing]
        .filter(([, e]) => (0, edge_1.edgeIncludesType)(e.types, edge_1.EdgeType.Calls))
        .map(([t]) => t);
    let builtIn = false;
    if (info.environment === undefined) {
        /* if we have a call with an unbound environment,
         * this only happens if we are sure of built-in relations and want to save references
         */
        builtIn = true;
    }
    else {
        /*
         * for performance and scoping reasons, flowR will not identify the global linkage,
         * including any potential built-in mapping.
         */
        const reResolved = (0, resolve_by_name_1.resolveByName)(info.name, info.environment, 1 /* ReferenceType.Unknown */);
        if (reResolved && reResolved.some(t => t.definedAt === built_in_1.BuiltIn)) {
            builtIn = true;
        }
    }
    switch (callTarget) {
        case call_context_query_format_1.CallTargets.Any:
            return callTargets;
        case call_context_query_format_1.CallTargets.OnlyGlobal:
            if (callTargets.length === 0) {
                return builtIn ? [built_in_1.BuiltIn] : [];
            }
            else {
                return 'no';
            }
        case call_context_query_format_1.CallTargets.MustIncludeGlobal:
            return builtIn || callTargets.length === 0 ? [...callTargets, built_in_1.BuiltIn] : 'no';
        case call_context_query_format_1.CallTargets.OnlyLocal:
            return !builtIn && callTargets.length > 0 ? callTargets : 'no';
        case call_context_query_format_1.CallTargets.MustIncludeLocal:
            if (callTargets.length > 0) {
                return builtIn ? [...callTargets, built_in_1.BuiltIn] : callTargets;
            }
            else {
                return 'no';
            }
        default:
            (0, assert_1.assertUnreachable)(callTarget);
    }
}
/* if the node is effected by nse, we have an ingoing nse edge */
function isQuoted(node, graph) {
    const vertex = graph.ingoingEdges(node);
    if (vertex === undefined) {
        return false;
    }
    return [...vertex.values()].some(({ types }) => (0, edge_1.edgeIncludesType)(types, edge_1.EdgeType.NonStandardEvaluation));
}
function makeReport(collector) {
    const result = {};
    for (const [kind, collected] of collector.store) {
        const subkinds = {};
        for (const [subkind, values] of collected) {
            subkinds[subkind] ??= [];
            const collectIn = subkinds[subkind];
            for (const value of values) {
                collectIn.push(value);
            }
        }
        result[kind] = {
            subkinds
        };
    }
    return result;
}
function isSubCallQuery(query) {
    return 'linkTo' in query;
}
function promoteQueryCallNames(queries) {
    let requiresCfg = false;
    const promotedQueries = queries.map(q => {
        if (isSubCallQuery(q)) {
            requiresCfg = true;
            return {
                ...q,
                callName: new RegExp(q.callName),
                linkTo: {
                    ...q.linkTo,
                    /* we have to add another promotion layer whenever we add something without this call name */
                    callName: new RegExp(q.linkTo.callName)
                }
            };
        }
        else {
            return {
                ...q,
                callName: new RegExp(q.callName)
            };
        }
    });
    return { promotedQueries, requiresCfg };
}
function identifyLinkToLastCallRelation(from, cfg, graph, linkTo) {
    const found = [];
    (0, visitor_1.visitInReverseOrder)(cfg, from, node => {
        /* we ignore the start id as it cannot be the last call */
        if (node === from) {
            return;
        }
        const vertex = graph.getVertex(node);
        if (vertex === undefined || vertex.tag !== vertex_1.VertexType.FunctionCall) {
            return;
        }
        if (linkTo.test(vertex.name)) {
            found.push(node);
            return true;
        }
    });
    return found;
}
/**
 * Multi-stage call context query resolve.
 *
 * 1. Resolve all calls in the DF graph that match the respective {@link DefaultCallContextQueryFormat#callName} regex.
 * 2. Identify their respective call targets, if {@link DefaultCallContextQueryFormat#callTargets} is set to be non-any.
 *    This happens during the main resolution!
 * 3. Attach `linkTo` calls to the respective calls.
 */
function executeCallContextQueries({ graph, ast }, queries) {
    /* omit performance page load */
    const now = Date.now();
    /* the node id and call targets if present */
    const initialIdCollector = new two_layer_collector_1.TwoLayerCollector();
    /* promote all strings to regex patterns */
    const { promotedQueries, requiresCfg } = promoteQueryCallNames(queries);
    let cfg = undefined;
    if (requiresCfg) {
        cfg = (0, cfg_1.extractCFG)(ast);
    }
    for (const [nodeId, info] of graph.vertices(true)) {
        if (info.tag !== vertex_1.VertexType.FunctionCall) {
            continue;
        }
        for (const query of promotedQueries.filter(q => q.callName.test(info.name))) {
            let targets = undefined;
            if (query.callTargets) {
                targets = satisfiesCallTargets(nodeId, graph, query.callTargets);
                if (targets === 'no') {
                    continue;
                }
            }
            if (isQuoted(nodeId, graph)) {
                /* if the call is quoted, we do not want to link to it */
                continue;
            }
            let linkedIds = undefined;
            if (cfg && isSubCallQuery(query)) {
                /* if we have a linkTo query, we have to find the last call */
                const lastCall = identifyLinkToLastCallRelation(nodeId, cfg.graph, graph, query.linkTo.callName);
                if (lastCall) {
                    linkedIds = lastCall;
                }
            }
            initialIdCollector.add(query.kind ?? '.', query.subkind ?? '.', (0, objects_1.compactRecord)({ id: nodeId, calls: targets, linkedIds }));
        }
    }
    return {
        '.meta': {
            timing: Date.now() - now,
        },
        kinds: makeReport(initialIdCollector)
    };
}
//# sourceMappingURL=call-context-query-executor.js.map