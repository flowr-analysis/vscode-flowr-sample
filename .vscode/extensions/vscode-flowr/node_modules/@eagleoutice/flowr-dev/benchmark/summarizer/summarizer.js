"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BenchmarkSummarizer = void 0;
const fs_1 = __importDefault(require("fs"));
const input_1 = require("./first-phase/input");
const process_1 = require("./second-phase/process");
const graph_1 = require("./second-phase/graph");
const path_1 = __importDefault(require("path"));
const summarizer_1 = require("../../util/summarizer");
const files_1 = require("../../util/files");
const json_1 = require("../../util/json");
const print_1 = require("../stats/print");
const defaultmap_1 = require("../../util/defaultmap");
class BenchmarkSummarizer extends summarizer_1.Summarizer {
    constructor(config) {
        super(config);
    }
    async preparationPhase() {
        this.removeIfExists(this.summaryFile());
        this.removeIfExists(this.config.intermediateOutputPath);
        fs_1.default.mkdirSync(this.config.intermediateOutputPath, { recursive: true });
        let fileNum = 0;
        const outputPathsPerRun = new defaultmap_1.DefaultMap(() => []);
        // recursively find all files in all the input path subdirectories
        for await (const file of (0, files_1.getAllFiles)(this.config.inputPath)) {
            const outputDir = path_1.default.join(this.config.intermediateOutputPath, path_1.default.relative(this.config.inputPath, file));
            fs_1.default.mkdirSync(outputDir, { recursive: true });
            const textOutputPath = path_1.default.join(outputDir, 'summary.log');
            // generate measurements for each run
            await (0, files_1.readLineByLine)(file, (line, lineNumber) => {
                const runOutputPath = path_1.default.join(outputDir, `run-${lineNumber}.json`);
                outputPathsPerRun.get(lineNumber).push(runOutputPath);
                return (0, input_1.processRunMeasurement)(line, fileNum, lineNumber, textOutputPath, runOutputPath);
            });
            fileNum++;
        }
        // generate combined measurements for each file per run
        for (const [run, paths] of outputPathsPerRun.entries()) {
            (0, input_1.processSummarizedRunMeasurement)(run, paths, this.summaryFile());
        }
        this.log('Done summarizing');
    }
    // eslint-disable-next-line @typescript-eslint/require-await -- just to obey the structure
    async summarizePhase() {
        this.log(`Summarizing all summaries from ${this.summaryFile()}...`);
        this.removeIfExists(this.config.outputPath);
        const summaries = [];
        (0, files_1.readLineByLineSync)(this.summaryFile(), (l) => (0, process_1.processNextUltimateSummary)(l, summaries));
        const ultimate = (0, process_1.summarizeAllUltimateStats)(summaries);
        this.log(`Writing ultimate summary to ${this.config.outputPath}`);
        fs_1.default.writeFileSync(this.config.outputPath, JSON.stringify(ultimate, json_1.jsonReplacer));
        console.log((0, print_1.ultimateStats2String)(ultimate));
        if (this.config.graphOutputPath) {
            (0, graph_1.writeGraphOutput)(ultimate, this.config.graphOutputPath);
        }
        return ultimate;
    }
    removeIfExists(path) {
        if (path && fs_1.default.existsSync(path)) {
            this.log(`Removing existing ${path}`);
            fs_1.default.rmSync(path, { recursive: true });
        }
    }
    summaryFile() {
        return `${this.config.intermediateOutputPath}.json`;
    }
}
exports.BenchmarkSummarizer = BenchmarkSummarizer;
//# sourceMappingURL=summarizer.js.map