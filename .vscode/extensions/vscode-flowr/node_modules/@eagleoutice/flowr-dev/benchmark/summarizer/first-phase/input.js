"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.processRunMeasurement = processRunMeasurement;
exports.processSummarizedRunMeasurement = processSummarizedRunMeasurement;
const fs_1 = __importDefault(require("fs"));
const process_1 = require("../second-phase/process");
const process_2 = require("./process");
const assert_1 = require("../../../util/assert");
const ansi_1 = require("../../../util/ansi");
const json_1 = require("../../../util/json");
const print_1 = require("../../stats/print");
async function processRunMeasurement(line, fileNum, lineNum, textOutputAppendPath, rawOutputPath) {
    let got = JSON.parse(line.toString());
    console.log(`[file ${fileNum}, line ${lineNum}] Summarize for ${got.filename}`);
    // now we have to recover the maps and bigints :C
    got = {
        ...got,
        stats: {
            ...got.stats,
            memory: new Map(got.stats.memory
                .map(([k, v]) => [k, v])),
            commonMeasurements: new Map(got.stats.commonMeasurements
                .map(([k, v]) => {
                (0, assert_1.guard)(v.endsWith('n'), 'Expected a bigint');
                return [k, BigInt(v.slice(0, -1))];
            })),
            perSliceMeasurements: new Map(got.stats.perSliceMeasurements
                .map(([k, v]) => mapPerSliceStats(k, v)))
        }
    };
    const totalSlices = got.stats.perSliceMeasurements.size;
    console.log(`Summarizing ${totalSlices} slices...`);
    let atSliceNumber = 0;
    const summarized = await (0, process_2.summarizeSlicerStats)(got.stats, (criterion, stats) => {
        console.log(`${ansi_1.escape}1F${ansi_1.escape}1G${ansi_1.escape}2K    [${++atSliceNumber}/${totalSlices}] Summarizing ${JSON.stringify(criterion)} (reconstructed has ${stats.reconstructedCode.code.length} characters)`);
        if (stats.reconstructedCode.code.length < 50) {
            console.log(`Reconstructed code: ${stats.reconstructedCode.code}`);
        }
    });
    console.log(`    - Write raw summary to ${rawOutputPath}`);
    fs_1.default.writeFileSync(rawOutputPath, `${JSON.stringify({
        filename: got.filename,
        'file-id': got['file-id'],
        'run-num': got['run-num'],
        summarize: summarized
    }, json_1.jsonReplacer)}\n`);
    console.log(`    - Append textual summary to ${textOutputAppendPath}`);
    fs_1.default.appendFileSync(textOutputAppendPath, `${(0, print_1.stats2string)(summarized)}\n`);
}
function processSummarizedRunMeasurement(runNum, summarizedFiles, appendPath) {
    console.log(`Summarizing all file statistics for run ${runNum}`);
    const summaries = [];
    for (const file of summarizedFiles) {
        (0, process_1.processNextSummary)(fs_1.default.readFileSync(file), summaries);
    }
    fs_1.default.appendFileSync(appendPath, `${JSON.stringify((0, process_1.summarizeAllSummarizedStats)(summaries), json_1.jsonReplacer)}\n`);
    console.log(`Appended summary of run ${runNum} to ${appendPath}`);
}
function mapPerSliceStats(k, v) {
    return [k, {
            reconstructedCode: v.reconstructedCode,
            slicingCriteria: v.slicingCriteria,
            timesHitThreshold: v.timesHitThreshold,
            measurements: new Map(v.measurements
                .map(([k, v]) => {
                (0, assert_1.guard)(v.endsWith('n'), 'Expected a bigint');
                return [k, BigInt(v.slice(0, -1))];
            })),
            numberOfDataflowNodesSliced: v.numberOfDataflowNodesSliced
        }];
}
//# sourceMappingURL=input.js.map