"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cfgToMermaid = cfgToMermaid;
exports.cfgToMermaidUrl = cfgToMermaidUrl;
const mermaid_1 = require("./mermaid");
function getLexeme(n) {
    return n ? n.info.fullLexeme ?? n.lexeme ?? '<unknown>' : '';
}
function cfgToMermaid(cfg, normalizedAst, prefix = '') {
    let output = prefix + 'flowchart TD\n';
    for (const [id, vertex] of cfg.graph.vertices()) {
        const normalizedVertex = normalizedAst.idMap.get(id);
        const content = getLexeme(normalizedVertex);
        if (content.length > 0) {
            const name = `"\`${(0, mermaid_1.escapeMarkdown)(vertex.name)} (${id})\n${(0, mermaid_1.escapeMarkdown)(JSON.stringify(content))}\`"`;
            output += `    n${id}[${name}]\n`;
        }
        else {
            output += `    n${id}(( ))\n`;
        }
    }
    for (const [from, targets] of cfg.graph.edges()) {
        for (const [to, edge] of targets) {
            const edgeType = edge.label === 'CD' ? '-->' : '-.->';
            const edgeSuffix = edge.label === 'CD' ? ` (${edge.when})` : '';
            output += `    n${from} ${edgeType}|"${(0, mermaid_1.escapeMarkdown)(edge.label)}${edgeSuffix}"| n${to}\n`;
        }
    }
    for (const entryPoint of cfg.entryPoints) {
        output += `    style n${entryPoint} stroke:cyan,stroke-width:6.5px;`;
    }
    for (const exitPoint of cfg.exitPoints) {
        output += `    style n${exitPoint} stroke:green,stroke-width:6.5px;`;
    }
    return output;
}
/**
 * Use mermaid to visualize the normalized AST.
 */
function cfgToMermaidUrl(cfg, normalizedAst, prefix = '') {
    return (0, mermaid_1.mermaidCodeToUrl)(cfgToMermaid(cfg, normalizedAst, prefix));
}
//# sourceMappingURL=cfg.js.map