"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.describeSchema = describeSchema;
exports.genericDescription = genericDescription;
exports.headerLine = headerLine;
exports.describeObject = describeObject;
const ansi_1 = require("./ansi");
function describeSchema(schema, f = ansi_1.formatter) {
    const description = schema.describe();
    const lines = genericDescription(1, f, f.format('.', { effect: ansi_1.ColorEffect.Foreground, color: 7 /* Colors.White */ }), description);
    const indent = ' '.repeat(4);
    return lines.map(line => `${indent.repeat(line.level - 1)}${line.text}`).join('\n');
}
function genericDescription(level, formatter, name, desc) {
    if (!desc) {
        return [];
    }
    const lines = [...headerLine(level, formatter, name, desc.type ?? 'unknown', desc.flags)];
    if ('allow' in desc) {
        lines.push({ level: level + 1, text: `Allows only the values: ${desc['allow'].map(v => "'" + v + "'").join(', ')}` });
    }
    switch (desc.type) {
        case 'object':
            lines.push(...describeObject(level, formatter, desc));
            break;
        case 'alternatives':
            if ('matches' in desc) {
                lines.push(...desc['matches']
                    .flatMap(({ schema }) => genericDescription(level + 1, formatter, '.', schema)));
            }
            break;
        case 'array':
            if ('items' in desc) {
                lines.push({ text: 'Valid item types:', level: level });
                lines.push(...desc['items']
                    .flatMap(desc => genericDescription(level + 1, formatter, '.', desc)));
            }
            break;
        default:
            /* specific support for others if needed */
            break;
    }
    return lines;
}
function printFlags(flags) {
    if (!flags || Object.keys(flags).length === 0) {
        return '';
    }
    let flagText = '';
    if ('presence' in flags) {
        flagText += flags['presence'] === 'required' ? 'required' : 'optional';
    }
    return flagText.trim().length > 0 ? '[' + flagText + ']' : '';
}
function headerLine(level, formatter, name, type, flags) {
    const text = `- ${(0, ansi_1.bold)(name, formatter)} ${formatter.format(type, { effect: ansi_1.ColorEffect.Foreground, color: 7 /* Colors.White */ })} ${printFlags(flags)}`;
    const baseLine = { level, text };
    if (flags && 'description' in flags) {
        return [baseLine, { level: level + 1, text: (0, ansi_1.italic)(flags['description'], formatter) }];
    }
    return [baseLine];
}
function describeObject(level, formatter, desc) {
    const lines = [];
    if (!('keys' in desc)) {
        return lines;
    }
    for (const key in desc.keys) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        const keySchema = desc.keys[key];
        lines.push(...genericDescription(level + 1, formatter, key, keySchema));
    }
    return lines;
}
//# sourceMappingURL=schema.js.map