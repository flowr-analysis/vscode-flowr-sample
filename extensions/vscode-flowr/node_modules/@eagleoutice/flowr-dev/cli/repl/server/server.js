"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlowRServer = exports.serverLog = void 0;
const repl_version_1 = require("../commands/repl-version");
const connection_1 = require("./connection");
const send_1 = require("./send");
const net_1 = require("./net");
const log_1 = require("../../../util/log");
// we detach from the main logger so that it can have its own switch
exports.serverLog = new log_1.FlowrLogger({ name: 'server' });
/**
 * This class controls the TCP server, which can be started by calling {@link start}.
 * Afterward, each incoming connection will be greeted with {@link helloClient} and from
 * thereon be handled by a {@link FlowRServerConnection}.
 */
class FlowRServer {
    server;
    shell;
    versionInformation;
    allowRSessionAccess = false;
    /** maps names to the respective connection */
    connections = new Map();
    nameCounter = 0;
    constructor(shell, allowRSessionAccess, server = new net_1.NetServer()) {
        this.server = server;
        this.server.onConnect(c => this.onConnect(c));
        this.shell = shell;
        this.allowRSessionAccess = allowRSessionAccess;
    }
    async start(port) {
        this.versionInformation = await (0, repl_version_1.retrieveVersionInformation)(this.shell);
        this.server.start(port);
        exports.serverLog.info(`Server listening on port ${port}`);
    }
    onConnect(c) {
        if (!this.versionInformation) {
            notYetInitialized(c, undefined);
            return;
        }
        const name = `client-${this.nameCounter++}`;
        exports.serverLog.info(`Client connected: ${(0, send_1.getUnnamedSocketName)(c)} as "${name}"`);
        this.connections.set(name, new connection_1.FlowRServerConnection(c, name, this.shell, this.allowRSessionAccess));
        helloClient(c, name, this.versionInformation);
        c.on('close', () => {
            this.connections.delete(name);
            exports.serverLog.info(`Client "${name}" disconnected (${(0, send_1.getUnnamedSocketName)(c)})`);
        });
    }
}
exports.FlowRServer = FlowRServer;
function notYetInitialized(c, id) {
    (0, send_1.sendMessage)(c, {
        id,
        type: 'error',
        fatal: true,
        reason: 'Server not initialized yet (or failed to), please try again later.'
    });
    c.end();
}
function helloClient(c, name, versionInformation) {
    (0, send_1.sendMessage)(c, {
        id: undefined,
        type: 'hello',
        clientName: name,
        versions: versionInformation
    });
}
//# sourceMappingURL=server.js.map