"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.queryStarCommand = exports.queryCommand = void 0;
exports.asciiSummaryOfQueryResult = asciiSummaryOfQueryResult;
const pipeline_executor_1 = require("../../../core/pipeline-executor");
const default_pipelines_1 = require("../../../core/steps/pipeline/default-pipelines");
const retriever_1 = require("../../../r-bridge/retriever");
const args_1 = require("../../../util/args");
const ansi_1 = require("../../../util/ansi");
const schema_1 = require("../../../util/schema");
const query_1 = require("../../../queries/query");
const json_1 = require("../../../util/json");
const query_schema_1 = require("../../../queries/query-schema");
const built_in_1 = require("../../../dataflow/environments/built-in");
async function getDataflow(shell, remainingLine) {
    return await new pipeline_executor_1.PipelineExecutor(default_pipelines_1.DEFAULT_DATAFLOW_PIPELINE, {
        shell,
        request: (0, retriever_1.requestFromInput)(remainingLine.trim())
    }).allRemainingSteps();
}
function printHelp(output) {
    output.stderr(`Format: ${(0, ansi_1.italic)(':query "<query>" <code>', output.formatter)}`);
    output.stdout('The query is an array of query objects to represent multiple queries. Each query object may have the following properties:');
    output.stdout((0, schema_1.describeSchema)(query_schema_1.AnyQuerySchema, output.formatter));
    output.stdout(`\n\nThe example ${(0, ansi_1.italic)(':query "[{\\"type\\": \\"call-context\\", \\"callName\\": \\"mean\\" }]" mean(1:10)', output.formatter)} would return the call context of the mean function.`);
    output.stdout('As a convenience, we interpret any (non-help) string not starting with \'[\' as a regex for the simple call-context query.');
    output.stdout(`Hence, ${(0, ansi_1.italic)(':query "mean" mean(1:10)', output.formatter)} is equivalent to the above example.`);
}
async function processQueryArgs(line, shell, output) {
    const args = (0, args_1.splitAtEscapeSensitive)(line);
    const query = args.shift();
    if (!query) {
        output.stderr(`No query provided, use ':query help' to get more information.`);
        return;
    }
    if (query === 'help') {
        printHelp(output);
        return;
    }
    let parsedQuery = [];
    if (query.startsWith('[')) {
        parsedQuery = JSON.parse(query);
        const validationResult = query_schema_1.QueriesSchema.validate(parsedQuery);
        if (validationResult.error) {
            output.stderr(`Invalid query: ${validationResult.error.message}`);
            printHelp(output);
            return;
        }
    }
    else {
        parsedQuery = [{ type: 'call-context', callName: query }];
    }
    const processed = await getDataflow(shell, args.join(' '));
    return {
        query: (0, query_1.executeQueries)({ graph: processed.dataflow.graph, ast: processed.normalize }, parsedQuery),
        processed
    };
}
function nodeString(id, formatter, processed) {
    if (id === built_in_1.BuiltIn) {
        return (0, ansi_1.italic)('built-in', formatter);
    }
    const node = processed.normalize.idMap.get(id);
    if (node === undefined) {
        return `UNKNOWN: ${id}`;
    }
    return `${(0, ansi_1.italic)('`' + (node.lexeme ?? node.info.fullLexeme ?? 'UNKNOWN') + '`', formatter)} (L.${node.location?.[0]})`;
}
function asciiCallContextSubHit(formatter, results, processed) {
    const result = [];
    for (const { id, calls = [], linkedIds = [] } of results) {
        const node = processed.normalize.idMap.get(id);
        if (node === undefined) {
            result.push(` ${(0, ansi_1.bold)('UNKNOWN: ' + JSON.stringify({ calls, linkedIds }))}`);
            continue;
        }
        let line = nodeString(id, formatter, processed);
        if (calls.length > 0) {
            line += ` with ${calls.length} call${calls.length > 1 ? 's' : ''} (${calls.map(c => nodeString(c, formatter, processed)).join(', ')})`;
        }
        if (linkedIds.length > 0) {
            line += ` with ${linkedIds.length} link${linkedIds.length > 1 ? 's' : ''} (${linkedIds.map(c => nodeString(c, formatter, processed)).join(', ')})`;
        }
        result.push(line);
    }
    return result.join(', ');
}
function asciiCallContext(formatter, results, processed) {
    /* traverse over 'kinds' and within them 'subkinds' */
    const result = [];
    for (const [kind, { subkinds }] of Object.entries(results['kinds'])) {
        result.push(`   ╰ ${(0, ansi_1.bold)(kind, formatter)}`);
        for (const [subkind, values] of Object.entries(subkinds)) {
            result.push(`     ╰ ${(0, ansi_1.bold)(subkind, formatter)}: ${asciiCallContextSubHit(formatter, values, processed)}`);
        }
    }
    return result.join('\n');
}
function asciiSummaryOfQueryResult(formatter, totalInMs, results, processed) {
    const result = [];
    for (const [query, queryResults] of Object.entries(results)) {
        if (query === '.meta') {
            continue;
        }
        if (query === 'call-context') {
            const out = queryResults;
            result.push(`Query: ${(0, ansi_1.bold)(query, formatter)} (${out['.meta'].timing.toFixed(0)}ms)`);
            result.push(asciiCallContext(formatter, out, processed));
            continue;
        }
        result.push(`Query: ${(0, ansi_1.bold)(query, formatter)}`);
        let timing = -1;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        for (const [key, value] of Object.entries(queryResults)) {
            if (key === '.meta') {
                timing = value.timing;
                continue;
            }
            result.push(` ╰ ${key}: ${JSON.stringify(value)}`);
        }
        result.push(`  - Took ${timing.toFixed(0)}ms`);
    }
    result.push((0, ansi_1.italic)(`All queries together required ≈${results['.meta'].timing.toFixed(0)}ms (1ms accuracy, total ${totalInMs.toFixed(0)}ms)`, formatter));
    return formatter.format(result.join('\n'));
}
exports.queryCommand = {
    description: `Query the given R code, start with '${retriever_1.fileProtocol}' to indicate a file. The query is to be a valid query in json format (use 'help' to get more information).`,
    usageExample: ':query "<query>" <code>',
    aliases: [],
    script: false,
    fn: async (output, shell, remainingLine) => {
        const totalStart = Date.now();
        const results = await processQueryArgs(remainingLine, shell, output);
        const totalEnd = Date.now();
        if (results) {
            output.stdout(asciiSummaryOfQueryResult(output.formatter, totalEnd - totalStart, results.query, results.processed));
        }
    }
};
exports.queryStarCommand = {
    description: 'Similar to query, but returns the output in json format.',
    usageExample: ':query* <query> <code>',
    aliases: [],
    script: false,
    fn: async (output, shell, remainingLine) => {
        const results = await processQueryArgs(remainingLine, shell, output);
        if (results) {
            output.stdout(JSON.stringify(results.query, json_1.jsonReplacer));
        }
    }
};
//# sourceMappingURL=repl-query.js.map