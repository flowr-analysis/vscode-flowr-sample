"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const log_1 = require("../util/log");
const assert_1 = require("../util/assert");
const json_1 = require("../util/json");
const script_1 = require("./common/script");
const slicer_1 = require("../benchmark/slicer");
const all_variables_1 = require("../slicing/criterion/filters/all-variables");
const path_1 = __importDefault(require("path"));
const options = (0, script_1.processCommandLineArgs)('benchmark-helper', [], {
    subtitle: 'Will slice for all possible variables, signal by exit code if slicing was successful, and can be run standalone',
    examples: [
        '{italic example-file.R} --output {italic output.json}',
        '{bold --help}'
    ]
});
if (options.verbose) {
    log_1.log.error('running with *verbose* setting - do not use for final benchmark', options);
}
const numberRegex = /^\d+$/;
(0, assert_1.guard)(options.slice === 'all' || options.slice === 'no' || numberRegex.test(options.slice), 'slice must be either all, no, or a number');
async function benchmark() {
    // we do not use the limit argument to be able to pick the limit randomly
    (0, assert_1.guard)(options.input !== undefined, 'No input file given');
    (0, assert_1.guard)(options.output !== undefined, 'No output file given');
    (0, assert_1.guard)((options['file-id'] === undefined) === (options['run-num'] === undefined), 'When giving a file-id or run-num, both have to be given');
    // prefix for printing to console, includes file id and run number if present
    const prefix = `[${options.input}${options['file-id'] !== undefined ? ` (file ${options['file-id']}, run ${options['run-num']})` : ''}]`;
    console.log(`${prefix} Appending output to ${options.output}`);
    fs_1.default.mkdirSync(path_1.default.parse(options.output).dir, { recursive: true });
    // ensure the file exists
    const fileStat = fs_1.default.statSync(options.input);
    (0, assert_1.guard)(fileStat.isFile(), `File ${options.input} does not exist or is no file`);
    const request = { request: 'file', content: options.input };
    const slicer = new slicer_1.BenchmarkSlicer();
    try {
        await slicer.init(request);
        // ${escape}1F${escape}1G${escape}2K for line reset
        if (options.slice === 'all') {
            const count = await slicer.sliceForAll(all_variables_1.DefaultAllVariablesFilter, (i, total, arr) => console.log(`${prefix} Slicing ${i + 1}/${total} [${JSON.stringify(arr[i])}]`));
            console.log(`${prefix} Completed Slicing`);
            (0, assert_1.guard)(count > 0, `No possible slices found for ${options.input}, skipping in count`);
        }
        else if (options.slice === 'no') {
            console.log(`${prefix} Skipping Slicing due to --slice=${options.slice}`);
        }
        else {
            const limit = parseInt(options.slice);
            console.log(`${prefix} Slicing up to ${limit} possible slices`);
            const count = await slicer.sliceForAll(all_variables_1.DefaultAllVariablesFilter, (i, total, arr) => console.log(`${prefix} Slicing ${i + 1}/${total} [${JSON.stringify(arr[i])}]`), limit);
            console.log(`${prefix} Completed Slicing`);
            (0, assert_1.guard)(count > 0, `No possible slices found for ${options.input}, skipping in count`);
        }
        const { stats } = slicer.finish();
        const output = {
            filename: options.input,
            'file-id': options['file-id'],
            'run-num': options['run-num'],
            stats
        };
        // append line by line
        console.log(`Appending benchmark of ${options.input} to ${options.output}`);
        fs_1.default.appendFileSync(options.output, `${JSON.stringify(output, json_1.jsonReplacer)}\n`);
    }
    catch (e) {
        if (e instanceof Error) {
            if (!e.message.includes('unable to parse R')) {
                console.log(`${prefix} Non R-Side error : ${e.message}`);
            }
        }
        slicer.ensureSessionClosed(); // ensure finish
        throw e;
    }
}
void benchmark();
//# sourceMappingURL=benchmark-helper-app.js.map