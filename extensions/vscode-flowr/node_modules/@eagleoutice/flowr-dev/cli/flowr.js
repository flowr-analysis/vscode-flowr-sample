"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultConfigFile = exports.optionHelp = exports.optionDefinitions = exports.toolName = void 0;
const server_1 = require("./repl/server/server");
const net_1 = require("./repl/server/net");
const version_1 = require("../util/version");
const log_1 = require("../util/log");
const ansi_1 = require("../util/ansi");
const command_line_args_1 = __importDefault(require("command-line-args"));
const command_line_usage_1 = __importDefault(require("command-line-usage"));
const config_1 = require("../config");
const assert_1 = require("../util/assert");
const scripts_info_1 = require("./common/scripts-info");
const shell_1 = require("../r-bridge/shell");
const execute_1 = require("./repl/execute");
const repl_main_1 = require("./repl/commands/repl-main");
const core_1 = require("./repl/core");
const repl_version_1 = require("./repl/commands/repl-version");
const print_version_1 = require("./repl/print-version");
let _scriptsText;
function getScriptsText() {
    if (_scriptsText === undefined) {
        _scriptsText = Array.from(Object.entries(scripts_info_1.scripts).filter(([, { type }]) => type === 'master script'), ([k,]) => k).join(', ');
    }
    return _scriptsText;
}
exports.toolName = 'flowr';
exports.optionDefinitions = [
    { name: 'config-file', type: String, description: 'The name of the configuration file to use', multiple: false },
    { name: 'config-json', type: String, description: 'The flowR configuration to use, as a JSON string', multiple: false },
    { name: 'execute', alias: 'e', type: String, description: 'Execute the given command and exit. Use a semicolon ";" to separate multiple commands.', typeLabel: '{underline command}', multiple: false },
    { name: 'help', alias: 'h', type: Boolean, description: 'Print this usage guide (or the guide of the corresponding script)' },
    { name: 'no-ansi', type: Boolean, description: 'Disable ansi-escape-sequences in the output. Useful, if you want to redirect the output to a file.' },
    { name: 'port', type: Number, description: 'The port to listen on, if --server is given.', defaultValue: 1042, typeLabel: '{underline port}' },
    { name: 'r-path', type: String, description: 'The path to the R executable to use. Defaults to your PATH.', multiple: false },
    { name: 'r-session-access', type: Boolean, description: 'Allow to access the underlying R session when using flowR (security warning: this allows the execution of arbitrary R code!)' },
    { name: 'script', alias: 's', type: String, description: `The sub-script to run (${getScriptsText()})`, multiple: false, defaultOption: true, typeLabel: '{underline files}', defaultValue: undefined },
    { name: 'server', type: Boolean, description: 'Do not drop into a repl, but instead start a server on the given port (default: 1042) and listen for messages.' },
    { name: 'verbose', alias: 'v', type: Boolean, description: 'Run with verbose logging (will be passed to the corresponding script)' },
    { name: 'version', alias: 'V', type: Boolean, description: 'Provide information about the version of flowR as well as its underlying R system and exit.' },
    { name: 'ws', type: Boolean, description: 'If the server flag is set, use websocket for messaging' }
];
exports.optionHelp = [
    {
        header: `flowR (version ${(0, version_1.flowrVersion)().toString()})`,
        content: 'A static dataflow analyzer and program slicer for R programs'
    },
    {
        header: 'Synopsis',
        content: [
            `$ ${exports.toolName} {bold --help}`,
            `$ ${exports.toolName} {bold --version}`,
            `$ ${exports.toolName} {bold --server}`,
            `$ ${exports.toolName} {bold --execute} {italic ":parse 2 - 4"}`,
            `$ ${exports.toolName} {bold slicer} {bold --help}`,
        ]
    },
    {
        header: 'Options',
        optionList: exports.optionDefinitions
    }
];
const options = (0, command_line_args_1.default)(exports.optionDefinitions);
log_1.log.updateSettings(l => l.settings.minLevel = options.verbose ? 1 /* LogLevel.Trace */ : 5 /* LogLevel.Error */);
log_1.log.info('running with options', options);
if (options['no-ansi']) {
    log_1.log.info('disabling ansi colors');
    (0, ansi_1.setFormatter)(ansi_1.voidFormatter);
}
exports.defaultConfigFile = 'flowr.json';
let usedConfig = false;
if (options['config-json']) {
    const config = (0, config_1.parseConfig)(options['config-json']);
    if (config) {
        log_1.log.info(`Using passed config ${JSON.stringify(config)}`);
        (0, config_1.setConfig)(config);
        usedConfig = true;
    }
}
if (!usedConfig) {
    (0, config_1.setConfigFile)(options['config-file'] ?? exports.defaultConfigFile, undefined, true);
}
function retrieveShell() {
    // we keep an active shell session to allow other parse investigations :)
    let opts = {
        revive: 2 /* RShellReviveOptions.Always */,
        onRevive: (code, signal) => {
            const signalText = signal == null ? '' : ` and signal ${signal}`;
            console.log(ansi_1.formatter.format(`R process exited with code ${code}${signalText}. Restarting...`, { color: 5 /* Colors.Magenta */, effect: ansi_1.ColorEffect.Foreground }));
            console.log((0, ansi_1.italic)(`If you want to exit, press either Ctrl+C twice, or enter ${(0, ansi_1.bold)(':quit')}`));
        }
    };
    if (options['r-path']) {
        opts = { ...opts, pathToRExecutable: options['r-path'] };
    }
    return new shell_1.RShell(opts);
}
async function mainRepl() {
    if (options.script) {
        const target = scripts_info_1.scripts[options.script].target;
        (0, assert_1.guard)(target !== undefined, `Unknown script ${options.script}, pick one of ${getScriptsText()}.`);
        console.log(`Running script '${ansi_1.formatter.format(options.script, { style: 1 /* FontStyles.Bold */ })}'`);
        log_1.log.debug(`Script maps to "${target}"`);
        await (0, execute_1.waitOnScript)(`${__dirname}/${target}`, process.argv.slice(3), undefined, true);
        process.exit(0);
    }
    if (options.help) {
        console.log((0, command_line_usage_1.default)(exports.optionHelp));
        process.exit(0);
    }
    if (options.version) {
        const shell = new shell_1.RShell();
        process.on('exit', () => shell.close());
        await (0, repl_version_1.printVersionInformation)(repl_main_1.standardReplOutput, shell);
        process.exit(0);
    }
    const shell = retrieveShell();
    const end = () => {
        if (options.execute === undefined) {
            console.log(`\n${(0, ansi_1.italic)('Exiting...')}`);
        }
        shell.close();
        process.exit(0);
    };
    // hook some handlers
    process.on('SIGINT', end);
    process.on('SIGTERM', end);
    const allowRSessionAccess = options['r-session-access'] ?? false;
    if (options.execute) {
        await (0, core_1.replProcessAnswer)(repl_main_1.standardReplOutput, options.execute, shell, allowRSessionAccess);
    }
    else {
        await (0, print_version_1.printVersionRepl)(shell);
        await (0, core_1.repl)({ shell, allowRSessionAccess });
    }
    process.exit(0);
}
async function mainServer(backend = new net_1.NetServer()) {
    const shell = retrieveShell();
    const end = () => {
        if (options.execute === undefined) {
            console.log(`\n${(0, ansi_1.italic)('Exiting...')}`);
        }
        shell.close();
        process.exit(0);
    };
    // hook some handlers
    process.on('SIGINT', end);
    process.on('SIGTERM', end);
    await new server_1.FlowRServer(shell, options['r-session-access'], backend).start(options.port);
}
if (options.server) {
    void mainServer(options.ws ? new net_1.WebSocketServerWrapper() : new net_1.NetServer());
}
else {
    void mainRepl();
}
//# sourceMappingURL=flowr.js.map