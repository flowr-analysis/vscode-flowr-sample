"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const assert_1 = require("../util/assert");
const files_1 = require("../util/files");
const log_1 = require("../util/log");
const parallel_1 = require("../util/parallel");
const script_1 = require("./common/script");
const options = (0, script_1.processCommandLineArgs)('benchmark', [], {
    subtitle: 'Slice given files with additional benchmark information',
    examples: [
        '{italic example-folder/}',
        '{bold --help}'
    ]
});
if (options.input.length === 0) {
    console.error('No input files given. Nothing to do. See \'--help\' if this is an error.');
    process.exit(0);
}
const numberRegex = /^\d+$/;
(0, assert_1.guard)(options.slice === 'all' || options.slice === 'no' || numberRegex.test(options.slice), 'slice must be either all, no, or a number');
(0, assert_1.guard)(options.runs === undefined || options.runs > 0, 'runs must be greater than zero');
function removeIfExists(summarizedRaw) {
    if (fs_1.default.existsSync(summarizedRaw)) {
        console.log(`Removing existing ${summarizedRaw}`);
        fs_1.default.rmSync(summarizedRaw, { recursive: true });
    }
}
async function benchmark() {
    removeIfExists(options.output);
    fs_1.default.mkdirSync(options.output, { recursive: true });
    console.log(`Storing output in ${options.output}`);
    console.log(`Using ${options.parallel} parallel executors`);
    // we do not use the limit argument to be able to pick the limit randomly
    const files = [];
    for (const input of options.input) {
        for await (const file of (0, files_1.allRFiles)(input)) {
            files.push({ request: file, baseDir: input });
        }
    }
    if (options.limit) {
        log_1.log.info(`limiting to ${options.limit} files`);
        // shuffle and limit
        files.sort(() => Math.random() - 0.5);
    }
    const limit = options.limit ?? files.length;
    const verboseAdd = options.verbose ? ['--verbose'] : [];
    const args = files.map((f, i) => [
        '--input', f.request.content,
        '--file-id', `${i}`,
        '--output', path_1.default.join(options.output, path_1.default.relative(f.baseDir, `${f.request.content}.json`)),
        '--slice', options.slice, ...verboseAdd
    ]);
    const runs = options.runs ?? 1;
    for (let i = 1; i <= runs; i++) {
        console.log(`Run ${i} of ${runs}`);
        const pool = new parallel_1.LimitedThreadPool(`${__dirname}/benchmark-helper-app`, 
        // we reverse here "for looks", since the helper pops from the end, and we want file ids to be ascending :D
        args.map(a => [...a, '--run-num', `${i}`]).reverse(), limit, options.parallel);
        await pool.run();
        const stats = pool.getStats();
        console.log(`Run ${i} of ${runs}: Benchmarked ${stats.counter} files, skipped ${stats.skipped.length} files due to errors`);
    }
}
void benchmark();
//# sourceMappingURL=benchmark-app.js.map