"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sliceDiffAnsi = sliceDiffAnsi;
const range_1 = require("../../util/range");
const assert_1 = require("../../util/assert");
const ansi_1 = require("../../util/ansi");
function grayOut() {
    return ansi_1.ansiFormatter.getFormatString({ color: 7 /* Colors.White */, effect: ansi_1.ColorEffect.Foreground, style: 2 /* FontStyles.Faint */ });
}
function mergeJointRangesInSorted(loc) {
    return loc.reduce((acc, curr) => {
        if ((0, range_1.rangesOverlap)(acc[acc.length - 1].location, curr.location)) {
            return [
                ...acc.slice(0, -1), {
                    selected: curr.selected || acc[acc.length - 1].selected,
                    location: (0, range_1.mergeRanges)(acc[acc.length - 1].location, curr.location)
                }
            ];
        }
        else {
            return [...acc, curr];
        }
    }, [loc[0]]);
}
function highlight(s, selected) {
    const primary = ansi_1.ansiFormatter.format(s, { color: 3 /* Colors.Yellow */, effect: ansi_1.ColorEffect.Foreground, style: 1 /* FontStyles.Bold */ });
    return selected ? ansi_1.ansiFormatter.format(primary, { style: 4 /* FontStyles.Underline */ }) : primary;
}
function sliceDiffAnsi(slice, normalized, criteriaIds, originalCode) {
    let importantLocations = Array.from(normalized.idMap.entries())
        .filter(([id, { location }]) => slice.has(id) && (0, assert_1.isNotUndefined)(location))
        .map(([id, { location }]) => ({ selected: criteriaIds.has(id), location: location }));
    if (importantLocations.length === 0) {
        return `${grayOut()}${originalCode}${ansi_1.ansiFormatter.reset()}`;
    }
    // we sort all locations from back to front so that replacements do not screw up the indices
    importantLocations.sort((a, b) => -(0, range_1.rangeCompare)(a.location, b.location));
    // we need to merge all ranges that overlap, otherwise even reversed traversal can still crew us up
    importantLocations = mergeJointRangesInSorted(importantLocations);
    const lines = originalCode.split('\n');
    for (const { selected, location } of importantLocations) {
        const [sl, sc, , ec] = location;
        const line = lines[sl - 1];
        lines[sl - 1] = `${line.substring(0, sc - 1)}${ansi_1.ansiFormatter.reset()}${highlight(line.substring(sc - 1, ec), selected)}${grayOut()}${line.substring(ec)}`;
    }
    return `${grayOut()}${lines.join('\n')}${ansi_1.ansiFormatter.reset()}`;
}
//# sourceMappingURL=slice-diff-ansi.js.map