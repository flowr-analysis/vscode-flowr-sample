"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeRootObjToAst = normalizeRootObjToAst;
const input_format_1 = require("../../input-format");
const normalize_meta_1 = require("../../normalize-meta");
const normalize_expressions_1 = require("./normalize-expressions");
const log_1 = require("../../../../../../../util/log");
const arrays_1 = require("../../../../../../../util/arrays");
function normalizeRootObjToAst(data, obj) {
    const exprContent = (0, input_format_1.getKeyGuarded)(obj, "exprlist" /* RawRType.ExpressionList */);
    (0, normalize_meta_1.assureTokenType)(exprContent, "exprlist" /* RawRType.ExpressionList */);
    let parsedChildren = [];
    if (input_format_1.childrenKey in exprContent) {
        const children = (0, input_format_1.getKeyGuarded)(exprContent, input_format_1.childrenKey);
        parsedChildren = (0, normalize_expressions_1.normalizeExpressions)(data, children);
    }
    else {
        log_1.log.debug('no children found, assume empty input');
    }
    const [delimiters, nodes] = (0, arrays_1.partition)(parsedChildren, x => x.type === "RDelimiter" /* RType.Delimiter */ || x.type === "RComment" /* RType.Comment */);
    return {
        type: "RExpressionList" /* RType.ExpressionList */,
        children: nodes,
        grouping: undefined,
        lexeme: undefined,
        info: {
            fullRange: data.currentRange,
            additionalTokens: delimiters,
            fullLexeme: data.currentLexeme
        }
    };
}
//# sourceMappingURL=normalize-root.js.map