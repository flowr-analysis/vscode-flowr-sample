"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryNormalizeFor = tryNormalizeFor;
const input_format_1 = require("../../input-format");
const parser_1 = require("../../../json/parser");
const normalize_meta_1 = require("../../normalize-meta");
const assert_1 = require("../../../../../../../util/assert");
const normalize_single_node_1 = require("../structure/normalize-single-node");
const normalize_expressions_1 = require("../structure/normalize-expressions");
const normalize_symbol_1 = require("../values/normalize-symbol");
const normalize_comment_1 = require("../other/normalize-comment");
function tryNormalizeFor(data, [forToken, head, body]) {
    // funny, for does not use top-level parenthesis
    if (forToken.name !== "FOR" /* RawRType.For */) {
        parser_1.parseLog.debug('encountered non-for token for supposed for-loop structure');
        return undefined;
    }
    else if (head.name !== "forcond" /* RawRType.ForCondition */) {
        throw new input_format_1.XmlParseError(`expected condition for for-loop but found ${JSON.stringify(head)}`);
    }
    else if (body.name !== "expr" /* RawRType.Expression */ && body.name !== "expr_or_assign_or_help" /* RawRType.ExprOfAssignOrHelp */ && body.name !== "equal_assign" /* RawRType.LegacyEqualAssign */) {
        throw new input_format_1.XmlParseError(`expected expr body for for-loop but found ${JSON.stringify(body)}`);
    }
    parser_1.parseLog.debug('trying to parse for-loop');
    const newParseData = { ...data, data, currentRange: undefined, currentLexeme: undefined };
    const { variable: parsedVariable, vector: parsedVector, comments } = normalizeForHead(newParseData, head.content);
    const parseBody = (0, normalize_single_node_1.normalizeSingleNode)(newParseData, body);
    if (parsedVariable === undefined ||
        parsedVector === undefined ||
        parseBody.type === "RDelimiter" /* RType.Delimiter */) {
        throw new input_format_1.XmlParseError(`unexpected under-sided for-loop, received ${JSON.stringify([
            parsedVariable,
            parsedVariable,
            parseBody,
        ])}`);
    }
    const { location, content } = (0, normalize_meta_1.retrieveMetaStructure)(forToken.content);
    return {
        type: "RForLoop" /* RType.ForLoop */,
        variable: parsedVariable,
        vector: parsedVector,
        body: (0, normalize_meta_1.ensureExpressionList)(parseBody),
        lexeme: content,
        info: {
            fullRange: data.currentRange,
            additionalTokens: comments,
            fullLexeme: data.currentLexeme,
        },
        location
    };
}
function normalizeForHead(data, forCondition) {
    // must have a child which is `in`, a variable on the left, and a vector on the right
    const children = (0, input_format_1.getKeyGuarded)(forCondition, input_format_1.childrenKey).map(content => ({ name: (0, normalize_meta_1.getTokenType)(content), content }));
    const { comments, others } = (0, normalize_expressions_1.splitComments)(children);
    const inPosition = others.findIndex(elem => elem.name === "IN" /* RawRType.ForIn */);
    (0, assert_1.guard)(inPosition > 0 && inPosition < others.length - 1, () => `for loop searched in and found at ${inPosition}, but this is not in legal bounds for ${JSON.stringify(children)}`);
    const variable = (0, normalize_symbol_1.tryNormalizeSymbol)(data, [others[inPosition - 1]]);
    (0, assert_1.guard)(variable !== undefined, () => `for loop variable should have been parsed to a symbol but was ${JSON.stringify(variable)}`);
    (0, assert_1.guard)(variable.type === "RSymbol" /* RType.Symbol */, () => `for loop variable should have been parsed to a symbol but was ${JSON.stringify(variable)}`);
    const vector = (0, normalize_expressions_1.normalizeExpressions)(data, [others[inPosition + 1]]);
    (0, assert_1.guard)(vector.length === 1 && vector[0].type !== "RDelimiter" /* RType.Delimiter */, () => `for loop vector should have been parsed to a single element but was ${JSON.stringify(vector)}`);
    const parsedComments = comments.map(c => (0, normalize_comment_1.normalizeComment)(data, c.content));
    return { variable, vector: vector[0], comments: parsedComments };
}
//# sourceMappingURL=normalize-for.js.map