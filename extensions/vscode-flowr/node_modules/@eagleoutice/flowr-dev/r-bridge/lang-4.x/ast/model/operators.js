"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnaryOperatorsInRAst = exports.OperatorsInRAst = exports.Operators = exports.OperatorDatabase = void 0;
/* eslint-disable */
exports.OperatorDatabase = {
    /* model formulae */
    '~': { name: 'model formulae', stringUsedInRAst: "~" /* RawRType.Tilde */, stringUsedInternally: '~', writtenAs: 'infix', arity: 3 /* OperatorArity.Both */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'model-formula', 'function-calls'] },
    /* arithmetic */
    '+': { name: 'addition or unary +', stringUsedInRAst: "+" /* RawRType.Plus */, stringUsedInternally: '+', writtenAs: 'infix', arity: 3 /* OperatorArity.Both */, usedAs: 'operation', capabilities: ['function-calls'] },
    '-': { name: 'subtraction or unary -', stringUsedInRAst: "-" /* RawRType.Minus */, stringUsedInternally: '-', writtenAs: 'infix', arity: 3 /* OperatorArity.Both */, usedAs: 'operation', capabilities: ['function-calls'] },
    '*': { name: 'multiplication', stringUsedInRAst: "*" /* RawRType.Times */, stringUsedInternally: '*', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls'] },
    '/': { name: 'division', stringUsedInRAst: "/" /* RawRType.Div */, stringUsedInternally: '/', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls'] },
    '^': { name: 'exponentiation', stringUsedInRAst: "^" /* RawRType.Exp */, stringUsedInternally: '^', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls'] },
    /* no error, R uses ^ to represent ** in the AST */
    '**': { name: 'alternative exponentiation', stringUsedInRAst: "^" /* RawRType.Exp */, stringUsedInternally: '**', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls'] },
    '%%': { name: 'modulus', stringUsedInRAst: '%%', stringUsedInternally: '%%', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'special-operator', 'function-calls'] },
    '%/%': { name: 'integer division', stringUsedInRAst: '%/%', stringUsedInternally: '%/%', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'special-operator', 'function-calls'] },
    '%*%': { name: 'matrix product', stringUsedInRAst: '%*%', stringUsedInternally: '%*%', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'special-operator', 'function-calls'] },
    '%o%': { name: 'outer product', stringUsedInRAst: '%o%', stringUsedInternally: '%o%', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'special-operator', 'function-calls'] },
    '%x%': { name: 'kronecker product', stringUsedInRAst: '%x%', stringUsedInternally: '%x%', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'special-operator', 'function-calls'] },
    /* comparison */
    '==': { name: 'equal to', stringUsedInRAst: "EQ" /* RawRType.Eq */, stringUsedInternally: '==', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls'] },
    '!=': { name: 'not equal to', stringUsedInRAst: "NE" /* RawRType.Ne */, stringUsedInternally: '!=', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls'] },
    '>': { name: 'greater than', stringUsedInRAst: "GT" /* RawRType.Gt */, stringUsedInternally: '>', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls'] },
    '>=': { name: 'greater than or equal to', stringUsedInRAst: "GE" /* RawRType.Ge */, stringUsedInternally: '>=', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls'] },
    '<': { name: 'less than', stringUsedInRAst: "LT" /* RawRType.Lt */, stringUsedInternally: '<', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls'] },
    '<=': { name: 'less than or equal to', stringUsedInRAst: "LE" /* RawRType.Le */, stringUsedInternally: '<=', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls'] },
    /* logical */
    '&': { name: 'logical and (vectorized)', stringUsedInRAst: "AND" /* RawRType.And */, stringUsedInternally: '&', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls', 'non-strict-logical-operators'] },
    '&&': { name: 'logical and (non-vectorized)', stringUsedInRAst: "AND2" /* RawRType.And2 */, stringUsedInternally: '&&', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls', 'non-strict-logical-operators'] },
    '|': { name: 'logical or (vectorized)', stringUsedInRAst: "OR" /* RawRType.Or */, stringUsedInternally: '|', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls', 'non-strict-logical-operators'] },
    '||': { name: 'logical or (not-vectorized)', stringUsedInRAst: "OR2" /* RawRType.Or2 */, stringUsedInternally: '||', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls', 'non-strict-logical-operators'] },
    '!': { name: 'unary not', stringUsedInRAst: "!" /* RawRType.Exclamation */, stringUsedInternally: '!', writtenAs: 'prefix', arity: 1 /* OperatorArity.Unary */, usedAs: 'operation', capabilities: ['unary-operator', 'function-calls'] },
    '%in%': { name: 'matching operator', stringUsedInRAst: '%in%', stringUsedInternally: '%in%', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'special-operator', 'function-calls'] },
    /* assignment */
    '<-': { name: 'left assignment', stringUsedInRAst: "LEFT_ASSIGN" /* RawRType.LeftAssign */, stringUsedInternally: '<-', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'assignment', capabilities: ['binary-operator', 'infix-calls', 'assignment-functions', 'local-left-assignment', 'function-calls'] },
    ':=': { name: 'left assignment', stringUsedInRAst: "LEFT_ASSIGN" /* RawRType.LeftAssign */, stringUsedInternally: ':=', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'assignment', capabilities: ['binary-operator', 'infix-calls', 'assignment-functions', 'local-table-assignment', 'function-calls'] },
    '<<-': { name: 'left global assignment', stringUsedInRAst: "LEFT_ASSIGN" /* RawRType.LeftAssign */, stringUsedInternally: '<<-', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'assignment', capabilities: ['binary-operator', 'infix-calls', 'assignment-functions', 'super-left-assignment', 'function-calls'] },
    '->': { name: 'right assignment', stringUsedInRAst: "RIGHT_ASSIGN" /* RawRType.RightAssign */, stringUsedInternally: '->', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'assignment', capabilities: ['binary-operator', 'infix-calls', 'assignment-functions', 'local-right-assignment', 'function-calls'] },
    '->>': { name: 'right global assignment', stringUsedInRAst: "RIGHT_ASSIGN" /* RawRType.RightAssign */, stringUsedInternally: '->>', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'assignment', capabilities: ['binary-operator', 'infix-calls', 'assignment-functions', 'super-right-assignment', 'function-calls'] },
    '=': { name: 'equal assignment', stringUsedInRAst: "EQ_ASSIGN" /* RawRType.EqualAssign */, stringUsedInternally: '=', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'assignment', capabilities: ['binary-operator', 'infix-calls', 'assignment-functions', 'local-equal-assignment', 'function-calls'] },
    /* others */
    /* maybe introduce custom in-r-ast flavor for these? we consider it arithmetic, as it works on numbers => if we change this we have to create custom tests! (with arithmetic, there is the automatic test set) */
    ':': { name: 'sequence operator', stringUsedInRAst: ":" /* RawRType.Colon */, stringUsedInternally: ':', writtenAs: 'infix', arity: 2 /* OperatorArity.Binary */, usedAs: 'operation', capabilities: ['binary-operator', 'infix-calls', 'function-calls'] },
    '?': { name: 'question', stringUsedInRAst: "?" /* RawRType.Question */, stringUsedInternally: '?', writtenAs: 'prefix', arity: 1 /* OperatorArity.Unary */, usedAs: 'operation', capabilities: ['unary-operator', 'built-in-help'] }
};
/* eslint-enable */
function buildOperatorRAstCollection(operators) {
    return new Set(operators.map(op => exports.OperatorDatabase[op].stringUsedInRAst));
}
exports.Operators = Object.keys(exports.OperatorDatabase);
// '**' will be treated as '^'
exports.OperatorsInRAst = buildOperatorRAstCollection(exports.Operators);
exports.UnaryOperatorsInRAst = buildOperatorRAstCollection(exports.Operators.filter(op => exports.OperatorDatabase[op].arity !== 2 /* OperatorArity.Binary */));
//# sourceMappingURL=operators.js.map