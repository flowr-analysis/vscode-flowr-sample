"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryNormalizeRepeat = tryNormalizeRepeat;
const parser_1 = require("../../../json/parser");
const assert_1 = require("../../../../../../../util/assert");
const normalize_meta_1 = require("../../normalize-meta");
const normalize_single_node_1 = require("../structure/normalize-single-node");
/**
 * Try to parse the construct as a {@link RRepeatLoop}.
 *
 * @param data        - The data used by the parser (see {@link NormalizerData})
 * @param repeatToken - Token which represents the `repeat` keyword
 * @param bodyToken   - The `body` of the repeat-loop
 *
 * @returns The parsed {@link RRepeatLoop} or `undefined` if the given construct is not a repeat-loop
 */
function tryNormalizeRepeat(data, [repeatToken, bodyToken]) {
    if (repeatToken.name !== "REPEAT" /* RawRType.Repeat */) {
        parser_1.parseLog.debug('encountered non-repeat token for supposed repeat-loop structure');
        return undefined;
    }
    parser_1.parseLog.debug('trying to parse repeat-loop');
    const parseBody = (0, normalize_single_node_1.normalizeSingleNode)(data, bodyToken);
    (0, assert_1.guard)(parseBody.type !== "RDelimiter" /* RType.Delimiter */, () => `no body for repeat-loop ${JSON.stringify(repeatToken)} (${JSON.stringify(bodyToken)})`);
    const { location, content } = (0, normalize_meta_1.retrieveMetaStructure)(repeatToken.content);
    return {
        type: "RRepeatLoop" /* RType.RepeatLoop */,
        location,
        lexeme: content,
        body: (0, normalize_meta_1.ensureExpressionList)(parseBody),
        info: {
            fullRange: data.currentRange,
            additionalTokens: [],
            fullLexeme: data.currentLexeme
        }
    };
}
//# sourceMappingURL=normalize-repeat.js.map