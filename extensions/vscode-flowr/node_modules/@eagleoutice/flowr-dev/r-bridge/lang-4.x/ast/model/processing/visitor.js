"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitAst = visitAst;
const assert_1 = require("../../../../../util/assert");
const r_function_call_1 = require("../nodes/r-function-call");
// capsuled as a class to avoid passing onExit and onEnter on *each* visit call
class NodeVisitor {
    onEnter;
    onExit;
    constructor(onEnter, onExit) {
        this.onEnter = onEnter;
        this.onExit = onExit;
    }
    visitSingle(node) {
        if (this.onEnter?.(node)) {
            return;
        }
        /* let the type system know that the type does not change */
        const type = node.type;
        switch (type) {
            case "RFunctionCall" /* RType.FunctionCall */:
                this.visitSingle(node.named ? node.functionName : node.calledFunction);
                this.visit(node.arguments);
                break;
            case "RFunctionDefinition" /* RType.FunctionDefinition */:
                this.visit(node.parameters);
                this.visitSingle(node.body);
                break;
            case "RExpressionList" /* RType.ExpressionList */:
                this.visit(node.grouping);
                this.visit(node.children);
                break;
            case "RForLoop" /* RType.ForLoop */:
                this.visitSingle(node.variable);
                this.visitSingle(node.vector);
                this.visitSingle(node.body);
                break;
            case "RWhileLoop" /* RType.WhileLoop */:
                this.visitSingle(node.condition);
                this.visitSingle(node.body);
                break;
            case "RRepeatLoop" /* RType.RepeatLoop */:
                this.visitSingle(node.body);
                break;
            case "RIfThenElse" /* RType.IfThenElse */:
                this.visitSingle(node.condition);
                this.visitSingle(node.then);
                this.visit(node.otherwise);
                break;
            case "RBinaryOp" /* RType.BinaryOp */:
            case "RPipe" /* RType.Pipe */:
                this.visitSingle(node.lhs);
                this.visitSingle(node.rhs);
                break;
            case "RUnaryOp" /* RType.UnaryOp */:
                this.visitSingle(node.operand);
                break;
            case "RParameter" /* RType.Parameter */:
                this.visitSingle(node.name);
                this.visit(node.defaultValue);
                break;
            case "RArgument" /* RType.Argument */:
                this.visit(node.name);
                this.visit(node.value);
                break;
            case "RAccess" /* RType.Access */:
                this.visitSingle(node.accessed);
                if (node.operator === '[' || node.operator === '[[') {
                    this.visit(node.access);
                }
                break;
            case "RSymbol" /* RType.Symbol */:
            case "RLogical" /* RType.Logical */:
            case "RNumber" /* RType.Number */:
            case "RString" /* RType.String */:
            case "RComment" /* RType.Comment */:
            case "RBreak" /* RType.Break */:
            case "RNext" /* RType.Next */:
            case "RLineDirective" /* RType.LineDirective */:
                // leafs
                break;
            default:
                (0, assert_1.assertUnreachable)(type);
        }
        this.onExit?.(node);
    }
    visit(nodes) {
        if (Array.isArray(nodes)) {
            const n = nodes;
            for (const node of n) {
                if (node && node !== r_function_call_1.EmptyArgument) {
                    this.visitSingle(node);
                }
            }
        }
        else if (nodes) {
            this.visitSingle(nodes);
        }
    }
}
/**
 * Collects all node ids within a tree given by a respective root node
 *
 * @param nodes          - The root id nodes to start collecting from
 * @param onVisit        - Called before visiting the subtree of each node. Can be used to stop visiting the subtree starting with this node (return `true` stop)
 * @param onExit         - Called after the subtree of a node has been visited, called for leafs too (even though their subtree is empty)
 */
function visitAst(nodes, onVisit, onExit) {
    return new NodeVisitor(onVisit, onExit).visit(nodes);
}
//# sourceMappingURL=visitor.js.map