"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.objectWithArrUnwrap = objectWithArrUnwrap;
exports.extractLocation = extractLocation;
exports.retrieveMetaStructure = retrieveMetaStructure;
exports.assureTokenType = assureTokenType;
exports.getTokenType = getTokenType;
exports.getWithTokenType = getWithTokenType;
exports.retrieveOpName = retrieveOpName;
exports.ensureChildrenAreLhsAndRhsOrdered = ensureChildrenAreLhsAndRhsOrdered;
exports.ensureExpressionList = ensureExpressionList;
const range_1 = require("../../../../../util/range");
const assert_1 = require("../../../../../util/assert");
const input_format_1 = require("./input-format");
/**
 * if the passed object is an array with only one element, remove the array wrapper
 */
function objectWithArrUnwrap(obj) {
    if (Array.isArray(obj)) {
        if (obj.length !== 1) {
            throw new input_format_1.XmlParseError(`expected only one element in the wrapped array, yet received ${JSON.stringify(obj)}`);
        }
        return obj[0];
    }
    else if (typeof obj === 'object') {
        return obj;
    }
    else {
        throw new input_format_1.XmlParseError(`expected array or object, yet received ${JSON.stringify(obj)}`);
    }
}
/**
 * given a xml element, extract the source location of the corresponding element in the R-ast
 */
function extractLocation(ast) {
    return (0, range_1.rangeFrom)(ast['line1'], ast['col1'], ast['line2'], ast['col2']);
}
/**
 * The json object that represents the input xml contains various meta-information.
 * This function extracts the meta-information and returns it.
 *
 * @param obj    - The json object to extract the meta-information from
 */
function retrieveMetaStructure(obj) {
    const unwrappedObj = objectWithArrUnwrap(obj);
    const attributes = obj[input_format_1.attributesKey];
    (0, assert_1.guard)(attributes !== undefined, () => `expected attributes to be defined for ${JSON.stringify(obj)}`);
    const content = obj[input_format_1.contentKey] ?? '';
    const location = extractLocation(attributes);
    return {
        unwrappedObj,
        location,
        content
    };
}
function assureTokenType(obj, expectedName) {
    const name = getTokenType(obj);
    if (name !== expectedName) {
        throw new input_format_1.XmlParseError(`expected name to be ${expectedName}, yet received ${name} for ${JSON.stringify(obj)}`);
    }
}
/**
 * Extract the token-type of the given object. This is based on the knowledge, that all json objects created
 * from the R xml have a name attached.
 *
 * @param content  - the json object to extract the token-type from
 */
function getTokenType(content) {
    return content[input_format_1.nameKey];
}
function getWithTokenType(obj) {
    return obj.map(content => ({
        name: getTokenType(content),
        content
    }));
}
function retrieveOpName(operator) {
    /*
   * only real arithmetic ops have their operation as their own name, the others identify via content
   */
    return operator.content[input_format_1.contentKey];
}
/**
 * Ensure that the first child is completely before the second child.
 *
 * @param first  - the first child which should be the lhs
 * @param second - the second child which should be the rhs
 */
function ensureChildrenAreLhsAndRhsOrdered(first, second) {
    const firstOtherLoc = extractLocation(first[input_format_1.attributesKey]);
    const secondOtherLoc = extractLocation(second[input_format_1.attributesKey]);
    if (!(0, range_1.rangeStartsCompletelyBefore)(firstOtherLoc, secondOtherLoc)) {
        throw new input_format_1.XmlParseError(`expected the first child to be the lhs, yet received ${JSON.stringify(first)} & ${JSON.stringify(second)}`);
    }
}
function ensureExpressionList(node) {
    if (node.type !== "RExpressionList" /* RType.ExpressionList */) {
        return {
            type: "RExpressionList" /* RType.ExpressionList */,
            grouping: undefined,
            location: node.location,
            info: node.info,
            lexeme: undefined,
            children: [node]
        };
    }
    return node;
}
//# sourceMappingURL=normalize-meta.js.map