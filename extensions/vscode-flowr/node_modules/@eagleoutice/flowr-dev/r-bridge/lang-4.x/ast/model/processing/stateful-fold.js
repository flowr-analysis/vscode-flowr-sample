"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.foldAstStateful = foldAstStateful;
const assert_1 = require("../../../../../util/assert");
const r_function_call_1 = require("../nodes/r-function-call");
/**
 * Folds in old functional-fashion over the AST structure but allowing for a down function which can pass context to child nodes.
 */
function foldAstStateful(ast, down, folds) {
    const type = ast.type;
    down = folds.down(ast, down);
    switch (type) {
        case "RNumber" /* RType.Number */:
            return folds.foldNumber(ast, down);
        case "RString" /* RType.String */:
            return folds.foldString(ast, down);
        case "RLogical" /* RType.Logical */:
            return folds.foldLogical(ast, down);
        case "RSymbol" /* RType.Symbol */:
            return folds.foldSymbol(ast, down);
        case "RComment" /* RType.Comment */:
            return folds.other.foldComment(ast, down);
        case "RLineDirective" /* RType.LineDirective */:
            return folds.other.foldLineDirective(ast, down);
        case "RPipe" /* RType.Pipe */:
            return folds.foldPipe(ast, foldAstStateful(ast.lhs, down, folds), foldAstStateful(ast.rhs, down, folds), down);
        case "RBinaryOp" /* RType.BinaryOp */:
            return folds.foldBinaryOp(ast, foldAstStateful(ast.lhs, down, folds), foldAstStateful(ast.rhs, down, folds), down);
        case "RUnaryOp" /* RType.UnaryOp */:
            return folds.foldUnaryOp(ast, foldAstStateful(ast.operand, down, folds), down);
        case "RAccess" /* RType.Access */:
            return folds.foldAccess(ast, foldAstStateful(ast.accessed, down, folds), ast.access.map(access => access === r_function_call_1.EmptyArgument ? r_function_call_1.EmptyArgument : foldAstStateful(access, down, folds)), down);
        case "RForLoop" /* RType.ForLoop */:
            return folds.loop.foldFor(ast, foldAstStateful(ast.variable, down, folds), foldAstStateful(ast.vector, down, folds), foldAstStateful(ast.body, down, folds), down);
        case "RWhileLoop" /* RType.WhileLoop */:
            return folds.loop.foldWhile(ast, foldAstStateful(ast.condition, down, folds), foldAstStateful(ast.body, down, folds), down);
        case "RRepeatLoop" /* RType.RepeatLoop */:
            return folds.loop.foldRepeat(ast, foldAstStateful(ast.body, down, folds), down);
        case "RFunctionCall" /* RType.FunctionCall */:
            return folds.functions.foldFunctionCall(ast, foldAstStateful(ast.named ? ast.functionName : ast.calledFunction, down, folds), ast.arguments.map(param => param === r_function_call_1.EmptyArgument ? param : foldAstStateful(param, down, folds)), down);
        case "RFunctionDefinition" /* RType.FunctionDefinition */:
            return folds.functions.foldFunctionDefinition(ast, ast.parameters.map(param => foldAstStateful(param, down, folds)), foldAstStateful(ast.body, down, folds), down);
        case "RParameter" /* RType.Parameter */:
            return folds.functions.foldParameter(ast, foldAstStateful(ast.name, down, folds), ast.defaultValue ? foldAstStateful(ast.defaultValue, down, folds) : undefined, down);
        case "RArgument" /* RType.Argument */:
            return folds.functions.foldArgument(ast, ast.name ? foldAstStateful(ast.name, down, folds) : undefined, ast.value ? foldAstStateful(ast.value, down, folds) : undefined, down);
        case "RNext" /* RType.Next */:
            return folds.loop.foldNext(ast, down);
        case "RBreak" /* RType.Break */:
            return folds.loop.foldBreak(ast, down);
        case "RIfThenElse" /* RType.IfThenElse */:
            return folds.foldIfThenElse(ast, foldAstStateful(ast.condition, down, folds), foldAstStateful(ast.then, down, folds), ast.otherwise === undefined ? undefined : foldAstStateful(ast.otherwise, down, folds), down);
        case "RExpressionList" /* RType.ExpressionList */:
            return folds.foldExprList(ast, ast.grouping ? [foldAstStateful(ast.grouping[0], down, folds), foldAstStateful(ast.grouping[1], down, folds)] : undefined, ast.children.map(expr => foldAstStateful(expr, down, folds)), down);
        default:
            (0, assert_1.assertUnreachable)(type);
    }
}
//# sourceMappingURL=stateful-fold.js.map