"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryNormalizeFunctionCall = tryNormalizeFunctionCall;
const input_format_1 = require("../../input-format");
const parser_1 = require("../../../json/parser");
const normalize_meta_1 = require("../../normalize-meta");
const arrays_1 = require("../../../../../../../util/arrays");
const assert_1 = require("../../../../../../../util/assert");
const normalize_argument_1 = require("./normalize-argument");
const r_function_call_1 = require("../../../../model/nodes/r-function-call");
const normalize_expression_1 = require("../expression/normalize-expression");
const normalize_string_1 = require("../values/normalize-string");
const normalize_symbol_1 = require("../values/normalize-symbol");
/**
 * Tries to parse the given data as a function call.
 *
 * @param data           - The data used by the parser (see {@link NormalizerData})
 * @param mappedWithName - The json object to extract the meta-information from
 *
 * @returns The parsed {@link RFunctionCall} (either named or unnamed) or `undefined` if the given construct is not a function call
 * May return a {@link RNext} or {@link RBreak} as `next()` and `break()` work as such.
 */
function tryNormalizeFunctionCall(data, mappedWithName) {
    const fnBase = mappedWithName[0];
    if (fnBase.name !== "expr" /* RawRType.Expression */ && fnBase.name !== "expr_or_assign_or_help" /* RawRType.ExprOfAssignOrHelp */ && fnBase.name !== "equal_assign" /* RawRType.LegacyEqualAssign */) {
        parser_1.parseLog.trace(`expected function call name to be wrapped an expression, yet received ${fnBase.name}`);
        return undefined;
    }
    if (mappedWithName.length < 3 || mappedWithName[1].name !== "(" /* RawRType.ParenLeft */ || mappedWithName[mappedWithName.length - 1].name !== ")" /* RawRType.ParenRight */) {
        parser_1.parseLog.trace('expected function call to have parenthesis for a call, but was not');
        return undefined;
    }
    parser_1.parseLog.trace('trying to parse function call');
    const { unwrappedObj, content, location } = (0, normalize_meta_1.retrieveMetaStructure)(fnBase.content);
    const symbolContent = (0, input_format_1.getKeyGuarded)(unwrappedObj, input_format_1.childrenKey);
    const namedSymbolContent = (0, normalize_meta_1.getWithTokenType)(symbolContent);
    if (namedSymbolContent.length === 1 && namedSymbolContent[0].name === "STR_CONST" /* RawRType.StringConst */) {
        // special handling when someone calls a function by string
        return parseNamedFunctionCall(data, namedSymbolContent, mappedWithName, location, content);
    }
    else if (namedSymbolContent.findIndex(x => x.name === "SYMBOL_FUNCTION_CALL" /* RawRType.SymbolFunctionCall */) < 0) {
        parser_1.parseLog.trace(`is not named function call, as the name is not of type ${"RFunctionCall" /* RType.FunctionCall */}, but: ${namedSymbolContent.map(n => n.name).join(',')}`);
        const mayResult = tryParseUnnamedFunctionCall(data, mappedWithName, location, content);
        return mayResult;
    }
    else {
        return parseNamedFunctionCall(data, namedSymbolContent, mappedWithName, location, content);
    }
}
function parseArguments(mappedWithName, data) {
    const argContainer = mappedWithName.slice(1);
    (0, assert_1.guard)(argContainer.length > 1 && argContainer[0].name === "(" /* RawRType.ParenLeft */ && argContainer[argContainer.length - 1].name === ")" /* RawRType.ParenRight */, 'expected args in parenthesis');
    const splitArgumentsOnComma = (0, arrays_1.splitArrayOn)(argContainer.slice(1, argContainer.length - 1), x => x.name === "," /* RawRType.Comma */);
    return splitArgumentsOnComma.map(x => {
        parser_1.parseLog.trace('trying to parse argument');
        return (0, normalize_argument_1.tryToNormalizeArgument)(data, x);
    });
}
function tryParseUnnamedFunctionCall(data, mappedWithName, location, content) {
    // maybe remove symbol-content again because I just use the root expr of mapped with name
    if (mappedWithName.length < 3) {
        parser_1.parseLog.trace('expected unnamed function call to have 3 elements [like (<func>)], but was not');
        return undefined;
    }
    parser_1.parseLog.trace('Assuming structure to be a function call');
    // we parse an expression to allow function calls
    const calledFunction = (0, normalize_expression_1.normalizeExpression)(data, mappedWithName[0].content);
    const parsedArguments = parseArguments(mappedWithName, data);
    if (parsedArguments.length === 0) {
        // sadly, next() and break() work
        if (calledFunction.type === "RNext" /* RType.Next */) {
            return {
                type: "RNext" /* RType.Next */,
                lexeme: content,
                location,
                info: {
                    fullRange: data.currentRange,
                    additionalTokens: [],
                    fullLexeme: data.currentLexeme
                }
            };
        }
        else if (calledFunction.type === "RBreak" /* RType.Break */) {
            return {
                type: "RBreak" /* RType.Break */,
                lexeme: content,
                location,
                info: {
                    fullRange: data.currentRange,
                    additionalTokens: [],
                    fullLexeme: data.currentLexeme
                }
            };
        }
    }
    return {
        type: "RFunctionCall" /* RType.FunctionCall */,
        named: undefined,
        location,
        lexeme: content,
        calledFunction: calledFunction,
        arguments: parsedArguments.map(x => x ?? r_function_call_1.EmptyArgument),
        info: {
            fullRange: data.currentRange,
            additionalTokens: [],
            fullLexeme: data.currentLexeme
        }
    };
}
function parseNamedFunctionCall(data, symbolContent, mappedWithName, location, content) {
    let functionName;
    if (symbolContent.length === 1 && symbolContent[0].name === "STR_CONST" /* RawRType.StringConst */) {
        const stringBase = (0, normalize_string_1.normalizeString)(data, symbolContent[0].content);
        functionName = {
            type: "RSymbol" /* RType.Symbol */,
            namespace: undefined,
            lexeme: stringBase.lexeme,
            info: stringBase.info,
            location: stringBase.location,
            content: stringBase.content.str
        };
    }
    else {
        functionName = (0, normalize_symbol_1.tryNormalizeSymbol)(data, symbolContent);
    }
    (0, assert_1.guard)(functionName !== undefined, 'expected function name to be a symbol, yet received none');
    (0, assert_1.guard)((functionName).type === "RSymbol" /* RType.Symbol */, () => `expected function name to be a symbol, yet received ${JSON.stringify(functionName)}`);
    const parsedArguments = parseArguments(mappedWithName, data);
    return {
        type: "RFunctionCall" /* RType.FunctionCall */,
        named: true,
        location,
        lexeme: content,
        functionName,
        arguments: parsedArguments.map(x => x ?? r_function_call_1.EmptyArgument),
        info: {
            fullRange: data.currentRange,
            additionalTokens: [],
            fullLexeme: data.currentLexeme
        }
    };
}
//# sourceMappingURL=normalize-call.js.map