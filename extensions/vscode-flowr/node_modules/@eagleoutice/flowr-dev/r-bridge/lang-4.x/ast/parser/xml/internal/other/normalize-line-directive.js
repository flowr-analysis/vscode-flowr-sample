"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeLineDirective = normalizeLineDirective;
const parser_1 = require("../../../json/parser");
const normalize_meta_1 = require("../../normalize-meta");
const assert_1 = require("../../../../../../../util/assert");
const LineDirectiveRegex = /^#line\s+(\d+)\s+"([^"]+)"\s*$/;
/**
 * Normalize the given object as an R line directive (`#line <number> "<file>"`).
 * This requires you to check the corresponding name beforehand.
 * If the given object turns out to be no line directive, this returns a normal comment instead.
 *
 * @param data - The data used by the parser (see {@link NormalizerData})
 * @param obj  - The json object to extract the meta-information from
 */
function normalizeLineDirective(data, obj) {
    const { location, content } = (0, normalize_meta_1.retrieveMetaStructure)(obj);
    (0, assert_1.guard)(content.startsWith('#line'), 'line directive must start with #line');
    const match = LineDirectiveRegex.exec(content);
    if (match === null) {
        parser_1.parseLog.debug(`[line-directive] does not match the regex ${LineDirectiveRegex.source} given ${JSON.stringify(content)}`);
        return {
            type: "RComment" /* RType.Comment */,
            location,
            lexeme: content,
            info: {
                fullRange: data.currentRange,
                additionalTokens: [],
                fullLexeme: content
            },
            content: content.slice(1)
        };
    }
    else {
        return {
            type: "RLineDirective" /* RType.LineDirective */,
            location,
            line: parseInt(match[1]),
            file: match[2],
            lexeme: content,
            info: {
                fullRange: data.currentRange,
                additionalTokens: [],
                fullLexeme: content
            }
        };
    }
}
//# sourceMappingURL=normalize-line-directive.js.map