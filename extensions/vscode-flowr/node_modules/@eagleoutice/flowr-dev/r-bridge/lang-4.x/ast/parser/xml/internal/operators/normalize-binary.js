"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryNormalizeBinary = tryNormalizeBinary;
const input_format_1 = require("../../input-format");
const parser_1 = require("../../../json/parser");
const normalize_meta_1 = require("../../normalize-meta");
const assert_1 = require("../../../../../../../util/assert");
const log_1 = require("../../../../../../../util/log");
const strings_1 = require("../../../../../../../util/strings");
const operators_1 = require("../../../../model/operators");
const normalize_single_node_1 = require("../structure/normalize-single-node");
/**
 * Parsing binary operations includes the pipe, even though the produced PIPE construct is not a binary operation,
 * to ensure it is handled separately from the others (especially in the combination of a pipe bind)
 */
function tryNormalizeBinary(data, [lhs, operator, rhs]) {
    (0, log_1.expensiveTrace)(parser_1.parseLog, () => `binary op for ${lhs.name} [${operator.name}] ${rhs.name}`);
    if (operator.name === "SPECIAL" /* RawRType.Special */ || operators_1.OperatorsInRAst.has(operator.name) || operator.name === "PIPE" /* RawRType.Pipe */) {
        return parseBinaryOp(data, lhs, operator, rhs);
    }
    else {
        return undefined;
    }
}
function parseBinaryOp(data, lhs, operator, rhs) {
    (0, normalize_meta_1.ensureChildrenAreLhsAndRhsOrdered)(lhs.content, rhs.content);
    const parsedLhs = (0, normalize_single_node_1.normalizeSingleNode)(data, lhs);
    const parsedRhs = (0, normalize_single_node_1.normalizeSingleNode)(data, rhs);
    if (parsedLhs.type === "RDelimiter" /* RType.Delimiter */ || parsedRhs.type === "RDelimiter" /* RType.Delimiter */) {
        throw new input_format_1.XmlParseError(`unexpected under-sided binary op, received ${JSON.stringify([parsedLhs, parsedRhs])} for ${JSON.stringify([lhs, operator, rhs])}`);
    }
    const operationName = (0, normalize_meta_1.retrieveOpName)(operator);
    const { location, content } = (0, normalize_meta_1.retrieveMetaStructure)(operator.content);
    if ((0, strings_1.startAndEndsWith)(operationName, '%')) {
        const lhsLoc = parsedLhs.type === "RExpressionList" /* RType.ExpressionList */ ? parsedLhs.grouping?.[0].location : parsedLhs.location;
        const rhsLoc = parsedRhs.type === "RExpressionList" /* RType.ExpressionList */ ? parsedRhs.grouping?.[0].location : parsedRhs.location;
        (0, assert_1.guard)(lhsLoc !== undefined && rhsLoc !== undefined, () => `special op lhs and rhs must have a locations, but ${JSON.stringify(parsedLhs)} || ${JSON.stringify(lhsLoc)} and ${JSON.stringify(parsedRhs)} ||  || ${JSON.stringify(rhsLoc)})`);
        // parse as infix function call!
        return {
            type: "RFunctionCall" /* RType.FunctionCall */,
            named: true,
            infixSpecial: true,
            lexeme: data.currentLexeme ?? content,
            location,
            functionName: {
                type: "RSymbol" /* RType.Symbol */,
                location,
                lexeme: content,
                content,
                namespace: undefined,
                info: {}
            },
            arguments: [
                {
                    type: "RArgument" /* RType.Argument */,
                    location: lhsLoc,
                    value: parsedLhs,
                    name: undefined,
                    lexeme: parsedLhs.lexeme ?? '',
                    info: {}
                },
                {
                    type: "RArgument" /* RType.Argument */,
                    location: rhsLoc,
                    value: parsedRhs,
                    name: undefined,
                    lexeme: parsedRhs.lexeme ?? '',
                    info: {}
                }
            ],
            info: {}
        };
    }
    else if (operator.name === "PIPE" /* RawRType.Pipe */) {
        (0, assert_1.guard)(parsedLhs.location !== undefined, () => `pipe lhs must have a location, but ${JSON.stringify(parsedLhs)})`);
        (0, assert_1.guard)(parsedLhs.lexeme !== undefined, () => `pipe lhs must have a full lexeme, but ${JSON.stringify(parsedLhs)})`);
        return {
            type: "RPipe" /* RType.Pipe */,
            location,
            lhs: {
                type: "RArgument" /* RType.Argument */,
                location: parsedLhs.location,
                value: parsedLhs,
                name: undefined,
                lexeme: parsedLhs.lexeme,
                info: {}
            },
            rhs: parsedRhs,
            lexeme: content,
            info: {
                fullRange: data.currentRange,
                additionalTokens: [],
                fullLexeme: data.currentLexeme
            }
        };
    }
    else {
        return {
            type: "RBinaryOp" /* RType.BinaryOp */,
            location,
            lhs: parsedLhs,
            rhs: parsedRhs,
            operator: operationName,
            lexeme: content,
            info: {
                fullRange: data.currentRange,
                additionalTokens: [],
                fullLexeme: data.currentLexeme
            }
        };
    }
}
//# sourceMappingURL=normalize-binary.js.map