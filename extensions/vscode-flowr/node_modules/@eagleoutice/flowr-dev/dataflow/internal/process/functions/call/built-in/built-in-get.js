"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processGet = processGet;
const known_call_handling_1 = require("../known-call-handling");
const unpack_argument_1 = require("../argument/unpack-argument");
const make_argument_1 = require("../argument/make-argument");
const logger_1 = require("../../../../../logger");
const retriever_1 = require("../../../../../../r-bridge/retriever");
const edge_1 = require("../../../../../graph/edge");
function processGet(name, args, rootId, data) {
    if (args.length !== 1) {
        logger_1.dataflowLogger.warn(`symbol access with ${name.content} has not 1 argument, skipping`);
        return (0, known_call_handling_1.processKnownFunctionCall)({ name, args, rootId, data }).information;
    }
    const retrieve = (0, unpack_argument_1.unpackArgument)(args[0]);
    if (retrieve === undefined || retrieve.type !== "RString" /* RType.String */) {
        logger_1.dataflowLogger.warn(`symbol access with ${name.content} has not 1 argument, skipping`);
        return (0, known_call_handling_1.processKnownFunctionCall)({ name, args, rootId, data }).information;
    }
    const treatTargetAsSymbol = {
        type: "RSymbol" /* RType.Symbol */,
        info: retrieve.info,
        content: (0, retriever_1.removeRQuotes)(retrieve.lexeme),
        lexeme: retrieve.lexeme,
        location: retrieve.location,
        namespace: undefined
    };
    const { information, processedArguments } = (0, known_call_handling_1.processKnownFunctionCall)({
        name,
        args: (0, make_argument_1.wrapArgumentsUnnamed)([treatTargetAsSymbol], data.completeAst.idMap),
        rootId,
        data
    });
    const firstArg = processedArguments[0];
    if (firstArg) {
        // get 'reads' its first argument
        information.graph.addEdge(rootId, firstArg.entryPoint, { type: edge_1.EdgeType.Reads });
    }
    return information;
}
//# sourceMappingURL=built-in-get.js.map