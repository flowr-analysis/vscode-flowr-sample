"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processNamedCall = processNamedCall;
const info_1 = require("../../../../info");
const known_call_handling_1 = require("./known-call-handling");
const append_1 = require("../../../../environments/append");
const resolve_by_name_1 = require("../../../../environments/resolve-by-name");
const vertex_1 = require("../../../../graph/vertex");
function mergeInformation(info, newInfo) {
    if (info === undefined) {
        return newInfo;
    }
    return {
        unknownReferences: [...info.unknownReferences, ...newInfo.unknownReferences],
        in: [...info.in, ...newInfo.in],
        out: [...info.out, ...newInfo.out],
        graph: info.graph.mergeWith(newInfo.graph),
        environment: (0, append_1.appendEnvironment)(info.environment, newInfo.environment),
        entryPoint: newInfo.entryPoint,
        exitPoints: [...info.exitPoints, ...newInfo.exitPoints],
    };
}
function processDefaultFunctionProcessor(information, name, args, rootId, data) {
    const resolve = (0, resolve_by_name_1.resolveByName)(name.content, data.environment, 2 /* ReferenceType.Function */);
    /* if we do not know where we land, we force! */
    const call = (0, known_call_handling_1.processKnownFunctionCall)({ name, args, rootId, data, forceArgs: (resolve?.length ?? 0) > 0 ? undefined : 'all' });
    return mergeInformation(information, call.information);
}
function processNamedCall(name, args, rootId, data) {
    const resolved = (0, resolve_by_name_1.resolveByName)(name.content, data.environment, 2 /* ReferenceType.Function */) ?? [];
    let defaultProcessor = resolved.length === 0;
    let information = undefined;
    let builtIn = false;
    for (const resolvedFunction of resolved) {
        if (resolvedFunction.type === 128 /* ReferenceType.BuiltInFunction */) {
            builtIn = true;
            information = mergeInformation(information, resolvedFunction.processor(name, args, rootId, data));
        }
        else {
            defaultProcessor = true;
        }
    }
    if (defaultProcessor) {
        information = processDefaultFunctionProcessor(information, name, args, rootId, data);
    }
    else if (information && builtIn) {
        // mark the function call as built in only
        const v = information.graph.getVertex(rootId);
        if (v?.tag === vertex_1.VertexType.FunctionCall) {
            v.onlyBuiltin = true;
            v.environment = undefined;
        }
    }
    return information ?? (0, info_1.initializeCleanDataflowInformation)(rootId, data);
}
//# sourceMappingURL=named-call-handling.js.map