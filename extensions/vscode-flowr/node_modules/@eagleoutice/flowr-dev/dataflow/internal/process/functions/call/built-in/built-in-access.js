"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processAccess = processAccess;
const assert_1 = require("../../../../../../util/assert");
const known_call_handling_1 = require("../known-call-handling");
const r_function_call_1 = require("../../../../../../r-bridge/lang-4.x/ast/model/nodes/r-function-call");
const logger_1 = require("../../../../../logger");
const edge_1 = require("../../../../../graph/edge");
const environment_1 = require("../../../../../environments/environment");
const built_in_1 = require("../../../../../environments/built-in");
const built_in_assignment_1 = require("./built-in-assignment");
function tableAssignmentProcessor(name, args, rootId, data, outInfo) {
    outInfo.definitionRootNodes.push(rootId);
    return (0, known_call_handling_1.processKnownFunctionCall)({ name, args, rootId, data }).information;
}
function processAccess(name, args, rootId, data, config) {
    if (args.length < 2) {
        logger_1.dataflowLogger.warn(`Access ${name.content} has less than 2 arguments, skipping`);
        return (0, known_call_handling_1.processKnownFunctionCall)({ name, args, rootId, data, forceArgs: config.forceArgs }).information;
    }
    const head = args[0];
    (0, assert_1.guard)(head !== r_function_call_1.EmptyArgument, () => `Access ${name.content} has no source, impossible!`);
    let fnCall;
    if (!config.treatIndicesAsString) {
        /* within an access operation which treats its fields, we redefine the table assignment ':=' as a trigger if this is to be treated as a definition */
        // do we have a local definition that needs to be recovered?
        const existing = data.environment.current.memory.get(':=');
        const outInfo = { definitionRootNodes: [] };
        data.environment.current.memory.set(':=', [{
                type: 128 /* ReferenceType.BuiltInFunction */,
                definedAt: built_in_1.BuiltIn,
                controlDependencies: undefined,
                processor: (name, args, rootId, data) => tableAssignmentProcessor(name, args, rootId, data, outInfo),
                name: ':=',
                nodeId: built_in_1.BuiltIn
            }]);
        fnCall = (0, known_call_handling_1.processKnownFunctionCall)({ name, args, rootId, data, forceArgs: config.forceArgs });
        /* recover the environment */
        if (existing !== undefined) {
            data.environment.current.memory.set(':=', existing);
        }
        if (head.value && outInfo.definitionRootNodes.length > 0) {
            (0, built_in_assignment_1.markAsAssignment)(fnCall.information, { type: 4 /* ReferenceType.Variable */, name: head.value.lexeme ?? '', nodeId: head.value.info.id, definedAt: rootId, controlDependencies: [] }, outInfo.definitionRootNodes, rootId);
        }
    }
    else {
        const newArgs = [...args];
        // if the argument is a symbol, we convert it to a string for this perspective
        for (let i = 1; i < newArgs.length; i++) {
            const arg = newArgs[i];
            if (arg !== r_function_call_1.EmptyArgument && arg.value?.type === "RSymbol" /* RType.Symbol */) {
                newArgs[i] = {
                    ...arg,
                    value: {
                        type: "RString" /* RType.String */,
                        info: arg.value.info,
                        lexeme: arg.value.lexeme,
                        location: arg.value.location,
                        content: {
                            quotes: 'none',
                            str: arg.value.lexeme
                        }
                    }
                };
            }
        }
        fnCall = (0, known_call_handling_1.processKnownFunctionCall)({ name, args: newArgs, rootId, data, forceArgs: config.forceArgs });
    }
    const info = fnCall.information;
    info.graph.addEdge(name.info.id, fnCall.processedArguments[0]?.entryPoint ?? head.info.id, { type: edge_1.EdgeType.Returns });
    /* access always reads all of its indices */
    for (const arg of fnCall.processedArguments) {
        if (arg !== undefined) {
            info.graph.addEdge(name.info.id, arg.entryPoint, { type: edge_1.EdgeType.Reads });
        }
        /* we include the read edges to the constant arguments as well so that they are included if necessary */
    }
    return {
        ...info,
        /*
     * Keep active nodes in case of assignments etc.
     * We make them maybe as a kind of hack.
     * This way when using
     * ```ts
     * a[[1]] <- 3
     * a[[2]] <- 4
     * a
     * ```
     * the read for a will use both accesses as potential definitions and not just the last one!
     */
        unknownReferences: (0, environment_1.makeAllMaybe)(info.unknownReferences, info.graph, info.environment, false),
        entryPoint: rootId,
        /** it is, to be precise, the accessed element we want to map to maybe */
        in: info.in.map(ref => {
            if (ref.nodeId === head.value?.info.id) {
                return (0, environment_1.makeReferenceMaybe)(ref, info.graph, info.environment, false);
            }
            else {
                return ref;
            }
        })
    };
}
//# sourceMappingURL=built-in-access.js.map