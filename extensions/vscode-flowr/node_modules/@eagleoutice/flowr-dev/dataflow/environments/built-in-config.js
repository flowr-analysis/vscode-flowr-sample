"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerBuiltInFunctions = registerBuiltInFunctions;
exports.registerReplacementFunctions = registerReplacementFunctions;
exports.registerBuiltInDefinition = registerBuiltInDefinition;
exports.registerBuiltInDefinitions = registerBuiltInDefinitions;
const built_in_1 = require("./built-in");
const assert_1 = require("../../util/assert");
function registerBuiltInConstant({ names, value, assumePrimitive }) {
    for (const name of names) {
        const d = [{
                type: 64 /* ReferenceType.BuiltInConstant */,
                definedAt: built_in_1.BuiltIn,
                controlDependencies: undefined,
                value,
                name,
                nodeId: built_in_1.BuiltIn
            }];
        built_in_1.BuiltInMemory.set(name, d);
        if (assumePrimitive) {
            built_in_1.EmptyBuiltInMemory.set(name, d);
        }
    }
}
function registerBuiltInFunctions({ names, processor, config, assumePrimitive }) {
    const mappedProcessor = built_in_1.BuiltInProcessorMapper[processor];
    (0, assert_1.guard)(mappedProcessor !== undefined, () => `Processor for ${processor} is undefined! Please pass a valid builtin name ${JSON.stringify(Object.keys(built_in_1.BuiltInProcessorMapper))}!`);
    for (const name of names) {
        (0, assert_1.guard)(processor !== undefined, `Processor for ${name} is undefined, maybe you have an import loop? You may run 'npm run detect-circular-deps' - although by far not all are bad`);
        const d = [{
                type: 128 /* ReferenceType.BuiltInFunction */,
                definedAt: built_in_1.BuiltIn,
                controlDependencies: undefined,
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-argument */
                processor: (name, args, rootId, data) => mappedProcessor(name, args, rootId, data, config),
                name,
                nodeId: built_in_1.BuiltIn
            }];
        built_in_1.BuiltInMemory.set(name, d);
        if (assumePrimitive) {
            built_in_1.EmptyBuiltInMemory.set(name, d);
        }
    }
}
/* registers all combinations of replacements */
function registerReplacementFunctions({ names, suffixes, assumePrimitive }) {
    const replacer = built_in_1.BuiltInProcessorMapper['builtin:replacement'];
    (0, assert_1.guard)(replacer !== undefined, () => 'Processor for builtin:replacement is undefined!');
    for (const assignment of names) {
        for (const suffix of suffixes) {
            const effectiveName = `${assignment}${suffix}`;
            const d = [{
                    type: 128 /* ReferenceType.BuiltInFunction */,
                    definedAt: built_in_1.BuiltIn,
                    processor: (name, args, rootId, data) => replacer(name, args, rootId, data, { makeMaybe: true, assignmentOperator: suffix }),
                    name: effectiveName,
                    controlDependencies: undefined,
                    nodeId: built_in_1.BuiltIn
                }];
            built_in_1.BuiltInMemory.set(effectiveName, d);
            if (assumePrimitive) {
                built_in_1.EmptyBuiltInMemory.set(effectiveName, d);
            }
        }
    }
}
function registerBuiltInDefinition(definition) {
    switch (definition.type) {
        case 'constant':
            return registerBuiltInConstant(definition);
        case 'function':
            return registerBuiltInFunctions(definition);
        case 'replacement':
            return registerReplacementFunctions(definition);
    }
}
function registerBuiltInDefinitions(definitions) {
    for (const definition of definitions) {
        registerBuiltInDefinition(definition);
    }
}
//# sourceMappingURL=built-in-config.js.map