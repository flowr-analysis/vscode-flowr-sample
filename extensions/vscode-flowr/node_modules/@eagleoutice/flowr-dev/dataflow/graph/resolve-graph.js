"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveDataflowGraph = resolveDataflowGraph;
const graph_1 = require("./graph");
const assert_1 = require("../../util/assert");
const parse_1 = require("../../slicing/criterion/parse");
const edge_1 = require("./edge");
/**
 * Resolves the dataflow graph ids from slicing criterion form to ids.
 * This returns a **new** graph with the resolved ids.
 */
function resolveDataflowGraph(graph, idMap) {
    const resolveMap = idMap ?? graph.idMap;
    (0, assert_1.guard)(resolveMap !== undefined, 'idMap must be provided to resolve the graph');
    const cache = new Map();
    const resolve = (id) => {
        const cached = cache.get(id);
        if (cached !== undefined) {
            return cached;
        }
        let resolved;
        try {
            resolved = (0, parse_1.slicingCriterionToId)(id, resolveMap);
        }
        catch (e) {
            /* just keep it :D */
            resolved = id;
        }
        cache.set(id, resolved);
        return resolved;
    };
    const resultGraph = new graph_1.DataflowGraph(resolveMap);
    const roots = graph.rootIds();
    /* recreate vertices */
    for (const [id, vertex] of graph.vertices(true)) {
        resultGraph.addVertex({
            ...vertex,
            id: resolve(id)
        }, roots.has(id));
    }
    /* recreate edges */
    for (const [from, targets] of graph.edges()) {
        for (const [to, info] of targets) {
            for (const type of (0, edge_1.splitEdgeTypes)(info.types)) {
                resultGraph.addEdge(resolve(from), resolve(to), { type });
            }
        }
    }
    return resultGraph;
}
//# sourceMappingURL=resolve-graph.js.map