"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.postProcess = postProcess;
const common_syntax_probability_1 = require("../../common-syntax-probability");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const arrays_1 = require("../../../../util/arrays");
const assert_1 = require("../../../../util/assert");
const numbers_1 = require("../../../../util/numbers");
const summarizer_1 = require("../../../../util/summarizer");
function appendOperators(base, b, filepath, config) {
    for (const [key, val] of Object.entries(b)) {
        let get = base.assignmentOperator[key];
        if (!get) {
            get = { uniqueFiles: new Set(), uniqueProjects: new Set(), counts: [] };
            base.assignmentOperator[key] = get;
        }
        const num = (0, numbers_1.bigint2number)(val);
        get.counts.push([num]);
        if (num > 0) {
            get.uniqueFiles.add(filepath);
            get.uniqueProjects.add(filepath.split(path_1.default.sep)[config.projectSkip] ?? '');
        }
    }
}
// returns a map that for each combination of operators found (like `<-,=`) returns the number of projects and files
// that use both of them
function retrieveUsageCombinationCounts(collected) {
    const ops = Object.keys(collected.assignmentOperator);
    if (ops.length < 1) {
        return new Map();
    }
    const allCombinations = [...(0, arrays_1.getUniqueCombinationsOfSize)(ops, 1)];
    const store = new Map();
    for (const combs of allCombinations) {
        if (combs.length === 1) {
            // we can just copy the information
            const { uniqueProjects, uniqueFiles } = collected.assignmentOperator[combs[0]];
            store.set(combs[0], { uniqueProjects, uniqueFiles });
            continue;
        }
        const existingKey = combs.slice(0, -1).join(',');
        const existing = store.get(existingKey);
        (0, assert_1.guard)(existing !== undefined, `Unable to retrieve cache for ${existingKey}`);
        const newKey = combs.join(',');
        const { uniqueProjects, uniqueFiles } = collected.assignmentOperator[combs[combs.length - 1]];
        const newUniqueProjects = new Set([...existing.uniqueProjects].filter(x => uniqueProjects.has(x)));
        const newUniqueFiles = new Set([...existing.uniqueFiles].filter(x => uniqueFiles.has(x)));
        store.set(newKey, { uniqueProjects: newUniqueProjects, uniqueFiles: newUniqueFiles });
    }
    const result = new Map();
    for (const [key, val] of store.entries()) {
        result.set(key, { uniqueProjects: val.uniqueProjects.size, uniqueFiles: val.uniqueFiles.size });
    }
    return result;
}
function writeOperatorCombinationsUsageToCsv(collected, outputPath) {
    // now to get all projects exhausted with _only_ a given subset (e.g., all projects only using '=')
    const operators = retrieveUsageCombinationCounts(collected);
    const out = fs_1.default.createWriteStream(path_1.default.join(outputPath, 'assignments-assigned-combinations.csv'));
    out.write('assignment,unique-projects,unique-files\n');
    for (const [key, val] of operators.entries()) {
        out.write(`${JSON.stringify(key)},${val.uniqueProjects},${val.uniqueFiles}\n`);
    }
    out.close();
}
function writeAssignmentMetadataToCsv(outputPath, collected) {
    const out = fs_1.default.createWriteStream(path_1.default.join(outputPath, 'assignments-meta.csv'));
    out.write(`kind,${(0, summarizer_1.summarizedMeasurement2CsvHeader)()}\n`);
    const summarizedDeepestNesting = (0, summarizer_1.summarizeMeasurement)(collected.deepestNesting.flat());
    out.write(`deepest-nesting,${(0, summarizer_1.summarizedMeasurement2Csv)(summarizedDeepestNesting)}\n`);
    const summarizedNestedOperatorAssignment = (0, summarizer_1.summarizeMeasurement)(collected.nestedOperatorAssignment.flat());
    out.write(`nested-operator-assignment,${(0, summarizer_1.summarizedMeasurement2Csv)(summarizedNestedOperatorAssignment)}\n`);
    out.close();
}
function writeAssignedTypesToCsv(outputPath, collected) {
    const out = fs_1.default.createWriteStream(path_1.default.join(outputPath, 'assignments-assigned.csv'));
    out.write(`kind,name,${(0, summarizer_1.summarizedMeasurement2CsvHeader)()}\n`);
    for (const [entryName, values] of Object.entries(collected.assigned)) {
        if (Array.isArray(values)) {
            out.write(`${JSON.stringify(entryName)},"",${(0, summarizer_1.summarizedMeasurement2Csv)((0, summarizer_1.summarizeMeasurement)(values.flat()))}\n`);
        }
        else {
            for (const [keyName, keyValue] of Object.entries(values)) {
                out.write(`${JSON.stringify(entryName)},${JSON.stringify(keyName)},${(0, summarizer_1.summarizedMeasurement2Csv)((0, summarizer_1.summarizeMeasurement)(keyValue.flat()))}\n`);
            }
        }
    }
    out.close();
}
function writeAssignmentOperatorsToCsv(outputPath, collected) {
    const fnOutStream = fs_1.default.createWriteStream(path_1.default.join(outputPath, 'assignments-assignment-operators.csv'));
    fnOutStream.write(`assignment,unique-projects,unique-files,${(0, summarizer_1.summarizedMeasurement2CsvHeader)()}\n`);
    for (const [key, val] of Object.entries(collected.assignmentOperator)) {
        const { uniqueProjects, uniqueFiles, counts } = val;
        const summarized = (0, summarizer_1.summarizedMeasurement2Csv)((0, summarizer_1.summarizeMeasurement)(counts.flat()));
        fnOutStream.write(`${JSON.stringify(key)},${uniqueProjects.size},${uniqueFiles.size},${summarized}\n`);
    }
    fnOutStream.close();
}
function postProcess(featureRoot, info, outputPath, config) {
    const collected = {
        assignmentOperator: {},
        assigned: (0, common_syntax_probability_1.emptyCommonSyntaxTypeCounts)(() => []),
        deepestNesting: [],
        nestedOperatorAssignment: []
    };
    for (const [filepath, data] of info.entries()) {
        const assignmentInfo = data.assignments;
        collected.deepestNesting.push([assignmentInfo.deepestNesting]);
        collected.nestedOperatorAssignment.push([assignmentInfo.nestedOperatorAssignment]);
        (0, common_syntax_probability_1.appendCommonSyntaxTypeCounter)(collected.assigned, assignmentInfo.assigned);
        appendOperators(collected, assignmentInfo.assignmentOperator, filepath, config);
    }
    writeAssignmentOperatorsToCsv(outputPath, collected);
    writeOperatorCombinationsUsageToCsv(collected, outputPath);
    writeAssignmentMetadataToCsv(outputPath, collected);
    writeAssignedTypesToCsv(outputPath, collected);
}
//# sourceMappingURL=post-process.js.map