"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.emptyCommonSyntaxTypeCounts = emptyCommonSyntaxTypeCounts;
exports.updateCommonSyntaxTypeCounts = updateCommonSyntaxTypeCounts;
exports.appendCommonSyntaxTypeCounter = appendCommonSyntaxTypeCounter;
exports.summarizeCommonSyntaxTypeCounter = summarizeCommonSyntaxTypeCounter;
/**
 * Defines the type of syntax constructs that we track (e.g., true, false, 0, 1, T, F, conditions...)
 */
const numbers_1 = require("../../util/numbers");
const summarizer_1 = require("../../util/summarizer");
const convert_values_1 = require("../../r-bridge/lang-4.x/convert-values");
function emptyCommonSyntaxTypeCounts(init = () => 0n) {
    return {
        total: init(),
        multiple: init(),
        empty: init(),
        withArgument: init(),
        noValue: init(),
        singleVar: {},
        number: {},
        integer: {},
        complex: {},
        string: {},
        logical: {},
        call: {},
        unnamedCall: init(),
        binOp: {},
        unaryOp: {},
        other: {}
    };
}
function incrementEntry(map, key) {
    map[key] = (map[key] ?? 0n) + 1n;
}
/**
 * Updates the given counts based on the type of the given node.
 */
function updateCommonSyntaxTypeCounts(current, ...nodes) {
    current.total++;
    if (nodes.length === 0) {
        current.empty++;
        return current;
    }
    else if (nodes.length > 1) {
        current.multiple++;
        return current;
    }
    let node = nodes[0];
    if (node.type === "RArgument" /* RType.Argument */) {
        if (node.name !== undefined) {
            current.withArgument++;
        }
        if (node.value !== undefined) {
            node = node.value;
        }
        else {
            current.noValue++;
            return current;
        }
    }
    switch (node.type) {
        case "RString" /* RType.String */:
            incrementEntry(current.string, node.content.str);
            break;
        case "RSymbol" /* RType.Symbol */:
            incrementEntry(current.singleVar, node.content);
            break;
        case "RLogical" /* RType.Logical */:
            incrementEntry(current.logical, node.content ? convert_values_1.RTrue : convert_values_1.RFalse);
            break;
        case "RNumber" /* RType.Number */:
            if (node.content.complexNumber) {
                incrementEntry(current.complex, node.content.num);
            }
            else if (node.content.markedAsInt) {
                incrementEntry(current.integer, node.content.num);
            }
            else {
                incrementEntry(current.number, node.content.num);
            }
            break;
        case "RFunctionCall" /* RType.FunctionCall */:
            if (!node.named) {
                current.unnamedCall++;
            }
            else {
                incrementEntry(current.call, node.functionName.content);
            }
            break;
        case "RBinaryOp" /* RType.BinaryOp */:
            incrementEntry(current.binOp, node.operator);
            break;
        case "RUnaryOp" /* RType.UnaryOp */:
            incrementEntry(current.unaryOp, node.operator);
            break;
        default:
            // for space reasons, we do not record the full lexeme!
            if (node.lexeme) {
                incrementEntry(current.other, node.lexeme);
            }
            break;
    }
    return current;
}
function appendRecord(a, b) {
    for (const [key, val] of Object.entries(b)) {
        const get = a[key];
        // we guard with array, to guard against methods like `toString` which are given in js
        if (!get || !Array.isArray(get)) {
            a[key] = [[(0, numbers_1.bigint2number)(val)]];
            continue;
        }
        get.push([(0, numbers_1.bigint2number)(val)]);
    }
}
function appendCommonSyntaxTypeCounter(a, b) {
    a.total.push([(0, numbers_1.bigint2number)(b.total)]);
    a.empty.push([(0, numbers_1.bigint2number)(b.empty)]);
    a.multiple.push([(0, numbers_1.bigint2number)(b.multiple)]);
    a.withArgument.push([(0, numbers_1.bigint2number)(b.withArgument)]);
    a.noValue.push([(0, numbers_1.bigint2number)(b.noValue)]);
    a.unnamedCall.push([(0, numbers_1.bigint2number)(b.unnamedCall)]);
    appendRecord(a.singleVar, b.singleVar);
    appendRecord(a.number, b.number);
    appendRecord(a.integer, b.integer);
    appendRecord(a.complex, b.complex);
    appendRecord(a.string, b.string);
    appendRecord(a.logical, b.logical);
    appendRecord(a.call, b.call);
    appendRecord(a.binOp, b.binOp);
    appendRecord(a.unaryOp, b.unaryOp);
    appendRecord(a.other, b.other);
}
function summarizeRecord(a) {
    return Object.fromEntries(Object.entries(a).map(([key, val]) => [key, (0, summarizer_1.summarizeMeasurement)(val.flat(), val.length)]));
}
function summarizeCommonSyntaxTypeCounter(a) {
    return {
        total: (0, summarizer_1.summarizeMeasurement)(a.total.flat(), a.total.length),
        empty: (0, summarizer_1.summarizeMeasurement)(a.empty.flat(), a.empty.length),
        multiple: (0, summarizer_1.summarizeMeasurement)(a.multiple.flat(), a.multiple.length),
        withArgument: (0, summarizer_1.summarizeMeasurement)(a.withArgument.flat(), a.withArgument.length),
        noValue: (0, summarizer_1.summarizeMeasurement)(a.noValue.flat(), a.noValue.length),
        unnamedCall: (0, summarizer_1.summarizeMeasurement)(a.unnamedCall.flat(), a.unnamedCall.length),
        singleVar: summarizeRecord(a.singleVar),
        number: summarizeRecord(a.number),
        integer: summarizeRecord(a.integer),
        complex: summarizeRecord(a.complex),
        string: summarizeRecord(a.string),
        logical: summarizeRecord(a.logical),
        call: summarizeRecord(a.call),
        binOp: summarizeRecord(a.binOp),
        unaryOp: summarizeRecord(a.unaryOp),
        other: summarizeRecord(a.other)
    };
}
//# sourceMappingURL=common-syntax-probability.js.map