"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatisticFileProvider = exports.defaultStatisticsFileSuffix = exports.DummyAppendProvider = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const log_1 = require("../../util/log");
const assert_1 = require("../../util/assert");
class DummyAppendProvider {
    map;
    /**
     * If you pass a map the dummy will log all append calls to the map, using the feature name and the appendage type as keys
     *
     * @param map - The map to log to
     */
    constructor(map = undefined) {
        this.map = map;
    }
    append(name, fn, content) {
        if (log_1.log.settings.minLevel >= 1 /* LogLevel.Trace */) {
            log_1.log.trace(`DummyAppendProvider: ${name} ${String(fn)} ${content}`);
        }
        if (this.map) {
            const fnMap = this.map.get(name);
            const contentArr = content.split('\n');
            if (fnMap) {
                const contentList = fnMap.get(fn);
                if (contentList) {
                    contentList.push(...contentArr);
                }
                else {
                    // just in case that the map already had some entries
                    fnMap.set(fn, contentArr);
                }
            }
            else {
                this.map.set(name, new Map([[fn, contentArr]]));
            }
        }
    }
}
exports.DummyAppendProvider = DummyAppendProvider;
exports.defaultStatisticsFileSuffix = '.txt';
/**
 * Provides cached open connections for all files to connect.
 * allowing to append to the same file often.
 * <p>
 * While we could simply reopen these files, it is safer/more performant to keep the connection open.
 */
class StatisticFileProvider {
    statisticsDirectory;
    connections = new Map();
    constructor(statisticsDirectory) {
        (0, assert_1.guard)(statisticsDirectory !== undefined, 'Please supply an output directory!');
        this.statisticsDirectory = statisticsDirectory;
        // just to make sure that they are closed
        process.on('beforeExit', () => {
            this.connections.forEach(fd => {
                fs_1.default.closeSync(fd);
            });
        });
    }
    /**
   * @param name - the name of the feature {@link Feature#name}
   * @param fn - the name of the feature-aspect to record
   */
    statisticsFile(name, fn) {
        return path_1.default.join(this.statisticsDirectory, name, `${fn}${exports.defaultStatisticsFileSuffix}`);
    }
    /**
   * Append the given content to the information for a feature of the given name and function.
   */
    append(name, fn, content) {
        const descriptor = this.getHandle(name, String(fn));
        fs_1.default.appendFileSync(descriptor, content + '\n', 'utf8');
    }
    getHandle(name, fn) {
        const key = `${name}-${fn}`;
        const fileHandle = this.connections.get(key);
        if (fileHandle) {
            return fileHandle;
        }
        // open the connection and ensure the location
        const filepath = this.statisticsFile(name, String(fn));
        const dirpath = path_1.default.dirname(filepath);
        if (!fs_1.default.existsSync(dirpath)) {
            fs_1.default.mkdirSync(dirpath, { recursive: true });
        }
        const fileDescriptor = fs_1.default.openSync(filepath, 'a');
        this.connections.set(key, fileDescriptor);
        return fileDescriptor;
    }
}
exports.StatisticFileProvider = StatisticFileProvider;
//# sourceMappingURL=file-provider.js.map