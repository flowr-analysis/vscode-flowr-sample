"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sliceForCall = sliceForCall;
exports.handleReturns = handleReturns;
const assert_1 = require("../../util/assert");
const fingerprint_1 = require("./fingerprint");
const linker_1 = require("../../dataflow/internal/linker");
const environment_1 = require("../../dataflow/environments/environment");
const scoping_1 = require("../../dataflow/environments/scoping");
const overwrite_1 = require("../../dataflow/environments/overwrite");
const graph_1 = require("../../dataflow/graph/graph");
const built_in_1 = require("../../dataflow/environments/built-in");
const resolve_by_name_1 = require("../../dataflow/environments/resolve-by-name");
const edge_1 = require("../../dataflow/graph/edge");
function retrieveActiveEnvironment(callerInfo, baseEnvironment) {
    let callerEnvironment = callerInfo.environment;
    const level = callerEnvironment?.level ?? 0;
    if (baseEnvironment.level !== level) {
        while (baseEnvironment.level < level) {
            baseEnvironment = (0, scoping_1.pushLocalEnvironment)(baseEnvironment);
        }
        while (baseEnvironment.level > level) {
            callerEnvironment = (0, scoping_1.pushLocalEnvironment)(callerEnvironment ?? (0, environment_1.initializeCleanEnvironments)(true));
        }
    }
    return (0, overwrite_1.overwriteEnvironment)(baseEnvironment, callerEnvironment);
}
function includeArgumentFunctionCallClosure(arg, baseEnvironment, activeEnvironment, queue, dataflowGraph) {
    const valueRoot = (0, graph_1.getReferenceOfArgument)(arg);
    if (!valueRoot) {
        return;
    }
    const callTargets = (0, linker_1.getAllLinkedFunctionDefinitions)(new Set([valueRoot]), dataflowGraph);
    linkCallTargets(false, callTargets, baseEnvironment, (0, fingerprint_1.envFingerprint)(baseEnvironment), activeEnvironment, (0, fingerprint_1.envFingerprint)(activeEnvironment), queue);
}
function linkCallTargets(onlyForSideEffects, functionCallTargets, baseEnvironment, baseEnvPrint, activeEnvironment, activeEnvironmentFingerprint, queue) {
    for (const functionCallTarget of functionCallTargets) {
        // all those linked within the scopes of other functions are already linked when exiting a function definition
        for (const openIn of functionCallTarget.subflow.in) {
            const defs = openIn.name ? (0, resolve_by_name_1.resolveByName)(openIn.name, activeEnvironment, openIn.type) : undefined;
            if (defs === undefined) {
                continue;
            }
            for (const def of defs.filter(d => d.nodeId !== built_in_1.BuiltIn)) {
                queue.add(def.nodeId, baseEnvironment, baseEnvPrint, onlyForSideEffects);
            }
        }
        for (const exitPoint of functionCallTarget.exitPoints) {
            queue.add(exitPoint, activeEnvironment, activeEnvironmentFingerprint, onlyForSideEffects);
        }
    }
}
/** returns the new threshold hit count */
function sliceForCall(current, callerInfo, dataflowGraph, queue) {
    // bind with call-local environments during slicing
    const outgoingEdges = dataflowGraph.get(callerInfo.id, true);
    (0, assert_1.guard)(outgoingEdges !== undefined, () => `outgoing edges of id: ${callerInfo.id} must be in graph but can not be found, keep in slice to be sure`);
    // lift baseEnv on the same level
    const baseEnvironment = current.baseEnvironment;
    const baseEnvPrint = (0, fingerprint_1.envFingerprint)(baseEnvironment);
    const activeEnvironment = retrieveActiveEnvironment(callerInfo, baseEnvironment);
    const activeEnvironmentFingerprint = (0, fingerprint_1.envFingerprint)(activeEnvironment);
    const name = callerInfo.name;
    (0, assert_1.guard)(name !== undefined, () => `name of id: ${callerInfo.id} can not be found in id map`);
    const functionCallDefs = (0, resolve_by_name_1.resolveByName)(name, activeEnvironment, 1 /* ReferenceType.Unknown */)?.filter(d => d.definedAt !== built_in_1.BuiltIn)?.map(d => d.nodeId) ?? [];
    for (const [target, outgoingEdge] of outgoingEdges[1].entries()) {
        if ((0, edge_1.edgeIncludesType)(outgoingEdge.types, edge_1.EdgeType.Calls)) {
            functionCallDefs.push(target);
        }
    }
    const functionCallTargets = (0, linker_1.getAllLinkedFunctionDefinitions)(new Set(functionCallDefs), dataflowGraph);
    if (functionCallTargets.size === 0) {
        /*
         * if we do not have any call to resolve this function, we have to assume that every function passed is actually called!
         * hence, we add a new flag and add all argument values to the queue causing directly
         */
        for (const arg of callerInfo.args) {
            includeArgumentFunctionCallClosure(arg, baseEnvironment, activeEnvironment, queue, dataflowGraph);
        }
        return;
    }
    linkCallTargets(current.onlyForSideEffects, functionCallTargets, baseEnvironment, baseEnvPrint, activeEnvironment, activeEnvironmentFingerprint, queue);
}
/** Returns true if we found at least one return edge */
function handleReturns(queue, currentEdges, baseEnvFingerprint, baseEnvironment) {
    const e = [...currentEdges.entries()];
    const found = e.filter(([_, edge]) => (0, edge_1.edgeIncludesType)(edge.types, edge_1.EdgeType.Returns));
    if (found.length === 0) {
        return false;
    }
    for (const [target,] of found) {
        queue.add(target, baseEnvironment, baseEnvFingerprint, false);
    }
    for (const [target, edge] of e) {
        if ((0, edge_1.edgeIncludesType)(edge.types, edge_1.EdgeType.Reads)) {
            queue.add(target, baseEnvironment, baseEnvFingerprint, false);
        }
        else if ((0, edge_1.edgeIncludesType)(edge.types, edge_1.EdgeType.Argument)) {
            queue.potentialArguments.set(target, {
                id: target,
                baseEnvironment,
                onlyForSideEffects: false
            });
        }
    }
    return true;
}
//# sourceMappingURL=slice-call.js.map