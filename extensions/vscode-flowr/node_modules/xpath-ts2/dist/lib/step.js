"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Step = void 0;
class Step {
    static ANCESTOR = 0;
    static ANCESTORORSELF = 1;
    static ATTRIBUTE = 2;
    static CHILD = 3;
    static DESCENDANT = 4;
    static DESCENDANTORSELF = 5;
    static FOLLOWING = 6;
    static FOLLOWINGSIBLING = 7;
    static NAMESPACE = 8;
    static PARENT = 9;
    static PRECEDING = 10;
    static PRECEDINGSIBLING = 11;
    static SELF = 12;
    static STEPNAMES = [
        [Step.ANCESTOR, 'ancestor'],
        [Step.ANCESTORORSELF, 'ancestor-or-self'],
        [Step.ATTRIBUTE, 'attribute'],
        [Step.CHILD, 'child'],
        [Step.DESCENDANT, 'descendant'],
        [Step.DESCENDANTORSELF, 'descendant-or-self'],
        [Step.FOLLOWING, 'following'],
        [Step.FOLLOWINGSIBLING, 'following-sibling'],
        [Step.NAMESPACE, 'namespace'],
        [Step.PARENT, 'parent'],
        [Step.PRECEDING, 'preceding'],
        [Step.PRECEDINGSIBLING, 'preceding-sibling'],
        [Step.SELF, 'self']
    ].reduce((acc, x) => {
        return (acc[x[0]] = x[1]), acc;
    }, {});
    static predicateString = (e) => `[${e.toString()}]`;
    static predicatesString = (es) => es.map(Step.predicateString).join('');
    axis;
    nodeTest;
    predicates;
    constructor(axis, nodetest, preds) {
        this.axis = axis;
        this.nodeTest = nodetest;
        this.predicates = preds;
    }
    toString() {
        return Step.STEPNAMES[this.axis] + '::' + this.nodeTest.toString() + Step.predicatesString(this.predicates);
    }
}
exports.Step = Step;
//# sourceMappingURL=step.js.map