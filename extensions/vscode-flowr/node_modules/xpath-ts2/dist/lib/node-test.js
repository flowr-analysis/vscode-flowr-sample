"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeTest = void 0;
const types_1 = require("./utils/types");
const xpath_namespace_1 = require("./xpath-namespace");
// tslint:disable:member-ordering
class NodeTest {
    static NAMETESTANY = 0;
    static NAMETESTPREFIXANY = 1;
    static NAMETESTQNAME = 2;
    static COMMENT = 3;
    static TEXT = 4;
    static PI = 5;
    static NODE = 6;
    static isNodeType(types) {
        return (n) => {
            return types.includes(n.nodeType) || (n.specified && types.includes(2)); // DOM4 support
        };
    }
    // create invariant node test for certain node types
    static makeNodeTypeTest(type, nodeTypes, stringVal) {
        return new class extends NodeTest {
            constructor() {
                super(type);
            }
            matches = NodeTest.isNodeType(nodeTypes);
            toString = () => stringVal;
        }();
    }
    static hasPrefix(node) {
        return node.prefix || (node.nodeName || node.tagName).indexOf(':') !== -1;
    }
    static isElementOrAttribute = NodeTest.isNodeType([1, 2]);
    static nameSpaceMatches(prefix, xpc, n) {
        const nNamespace = ((0, types_1.isElement)(n) || (0, types_1.isAttribute)(n) ? n.namespaceURI : undefined) || '';
        if (!prefix) {
            return !nNamespace || (xpc.allowAnyNamespaceForNoPrefix && !NodeTest.hasPrefix(n));
        }
        const ns = xpc.namespaceResolver.getNamespace(prefix, n);
        if (ns == null) {
            // throw new Error('Cannot resolve QName ' + prefix);
            return false;
        }
        return ns === nNamespace;
    }
    static localNameMatches = (localName, xpc, n) => {
        const nLocalName = n.localName || n.nodeName;
        return xpc.caseInsensitive ? localName.toLowerCase() === nLocalName.toLowerCase() : localName === nLocalName;
        // tslint:disable-next-line:semicolon
    };
    // tslint:disable-next-line:variable-name
    static NameTestPrefixAny = class extends NodeTest {
        prefix;
        constructor(prefix) {
            super(NodeTest.NAMETESTPREFIXANY);
            this.prefix = prefix;
        }
        matches(n, xpc) {
            return NodeTest.isElementOrAttribute(n) && NodeTest.nameSpaceMatches(this.prefix, xpc, n);
        }
        toString() {
            return this.prefix + ':*';
        }
    };
    // tslint:disable-next-line:variable-name
    static NameTestQName = class extends NodeTest {
        name;
        prefix;
        localName;
        constructor(name) {
            super(NodeTest.NAMETESTQNAME);
            const nameParts = name.split(':');
            this.name = name;
            this.prefix = nameParts.length > 1 ? nameParts[0] : null;
            this.localName = nameParts[nameParts.length > 1 ? 1 : 0];
        }
        matches(n, xpc) {
            return (NodeTest.isNodeType([1, 2, xpath_namespace_1.XPathNamespace.XPATH_NAMESPACE_NODE])(n) &&
                NodeTest.nameSpaceMatches(this.prefix, xpc, n) &&
                NodeTest.localNameMatches(this.localName, xpc, n));
        }
        toString() {
            return this.name;
        }
    };
    // tslint:disable-next-line:variable-name
    static PITest = class extends NodeTest {
        name;
        constructor(name) {
            super(NodeTest.PI);
            this.name = name;
        }
        matches(n, _xpc) {
            return NodeTest.isNodeType([7])(n) && (n.target || n.nodeName) === this.name;
        }
        toString() {
            return `processing-instruction("${this.name}")`;
        }
    };
    // elements, attributes, namespaces
    static nameTestAny = NodeTest.makeNodeTypeTest(NodeTest.NAMETESTANY, [1, 2, xpath_namespace_1.XPathNamespace.XPATH_NAMESPACE_NODE], '*');
    // text, cdata
    static textTest = NodeTest.makeNodeTypeTest(NodeTest.TEXT, [3, 4], 'text()');
    static commentTest = NodeTest.makeNodeTypeTest(NodeTest.COMMENT, [8], 'comment()');
    // elements, attributes, text, cdata, PIs, comments, document nodes
    static nodeTest = NodeTest.makeNodeTypeTest(NodeTest.NODE, [1, 2, 3, 4, 7, 8, 9], 'node()');
    static anyPiTest = NodeTest.makeNodeTypeTest(NodeTest.PI, [7], 'processing-instruction()');
    type;
    constructor(type) {
        this.type = type;
    }
    toString() {
        return '<unknown nodetest type>';
    }
    matches(_n, _xpc) {
        // tslint:disable-next-line:no-console
        console.warn('unknown node test type');
        return false;
    }
}
exports.NodeTest = NodeTest;
//# sourceMappingURL=node-test.js.map